{"meta":{"title":"Ender_'s Blog","subtitle":"","description":"","author":"Ender","url":"https://ender-003.github.io","root":"/"},"pages":[],"posts":[{"title":"图笔记 Ⅱ(存储&便利)","slug":"图笔记","date":"2021-04-24T09:59:59.778Z","updated":"2021-04-24T08:29:44.122Z","comments":true,"path":"2021/04/24/图笔记/","link":"","permalink":"https://ender-003.github.io/2021/04/24/%E5%9B%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"存储1. 直接存边使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权） Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct Edge &#123; int u, v, w; // 一条边的 起点、终点、权值&#125;;int n, m;vector&lt;Edge&gt; e;vector&lt;bool&gt; vis;bool find_edge(int u, int v) &#123; for (int i = 1; i &lt;= m; ++i) &#123; if (e[i].u == u &amp;&amp; e[i].v == v) &#123; return true; &#125; &#125; return false;&#125;void dfs(int u) &#123; if (vis[u]) return; vis[u] = true; for (int i = 1; i &lt;= m; ++i) &#123; if (e[i].u == u) &#123; dfs(e[i].v); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; vis.resize(n + 1, false); e.resize(m + 1); for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v; return 0;&#125; 复杂度查询是否存在某条边： $O(m)$ 。 遍历一个点的所有出边： $O(m)$ 。 遍历整张图： $O(nm)$ 。 空间复杂度： $O(m)$ 。 应用由于直接存边的遍历效率低下，一般不用于遍历图。 在 $Kruskal$ 算法中，由于需要将边按边权排序，需要直接存边。 在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。 2. 邻接矩阵使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 uu 到 vv 的边，为 0 表示不存在。 如果是带边权的图，可以在 adj[u][v] 中存储 uu 到 vv 的边的边权，0 表示没有连接，其他值表示权重。 如果是无向图，则将一条无向边拆成两条方向相反的边即可。（所谓的「无向」，也就等同于「双向」） Code:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5+5;int n, m;bool vis[N];bool adj[N][N];bool find_edge(int u, int v) &#123; return adj[u][v]; &#125;void dfs(int u) &#123; if (vis[u]) return; vis[u] = true; for (int v = 1; v &lt;= n; ++v) &#123; if (adj[u][v]) &#123; dfs(v); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; fill_n(vis, N, false); fill_n(adj, N*N, false); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u][v] = true; // u-&gt;v 有条单向边 // 如果是双向边 // adj[u][v] = adj[v][u] = true; &#125; return 0;&#125; 复杂度查询是否存在某条边： $O(1)$ 。 遍历一个点的所有出边： $O(n)$ 。 遍历整张图： $O(n^2)$ 。 空间复杂度： $O(n^2)$ 。 应用邻接矩阵只适用于没有重边（或重边可以忽略）的情况。 其最显著的优点是可以 $O(1)$ 查询一条边是否存在。 由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会 在稠密图上使用邻接矩阵。并且，在稠密图上使用邻接矩阵的运行效率远高于邻接表，这是因为 CPU 中顺序访问的速度是远高于随机访问的（缓存命中）。 遍历深度优先遍历1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5+5;int n, m;bool vis[N]; // 标记是否访问过bool adj[N][N]; // 邻接矩阵存图void dfs(int u) &#123; vis[u] = true; for (int v = 1; v &lt;= n; ++v) &#123; if (adj[u][v] &amp;&amp; !vis[u]) &#123; // 有边，并且没访问过，访问 dfs(v); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; fill_n(vis, N, false); fill_n(adj, N*N, false); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u][v] = true; // u-&gt;v 有条单向边 // 如果是双向边 // adj[u][v] = adj[v][u] = true; &#125; dfs(1); return 0;&#125; 广度优先遍历1234567891011121314151617const int N = 1e5+5;int n, m;bool vis[N]; // 标记是否访问过bool adj[N][N]; // 邻接矩阵存图void bfs(int s) &#123; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int k = q.front(); q.pop(); cout &lt;&lt; k &lt;&lt; &quot; &quot;; for(int i = 1; i &lt;= n; i++) &#123; if (adj[k][i] &amp;&amp; !vis[i]) // 有边，并且没访问过，访问 q.push(i); &#125; &#125;&#125; 最短路FloydFeatures 时间复杂度是 $O(n^3)$ ，因此，只适用于 $n &lt; 500$ 的这种结点数不多的情况。 它是多源最短路的，可以求出任何两点之间的最短路。 支持负边权 能够判断图中是否存在负回路 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int N=510;int g[N][N];int dis[N][N]; // dis[i][j]: i-&gt;j 最短距离 /*证明：定义 dis[i][j][k] 表示从 i 到 j 的可以经过 1~k 号结点的最短路径，此问题可以被分解为两个子问题（1）不经过 k 号结点，即 dis[i][j][k-1]（2）经过 k 号结点，即 dis[i][k][k-1]+dis[k][j][k-1];因此，有：dis[i][j][k] = min(dis[i][j][k-1], dis[i][k][k-1], dis[k][j][k-1]);上式中第三维 k 可以省略，则有： dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);虽然 i,j,k 的顺序不保证，导致上式中 dis[i][k] 和 dis[k][j] 可能是已经被更新过的 dis[i][k][k] 和 dis[k][j][k] 了，但是这并不影响其正确性。因为更新后的值一定会变得更小，不会影响最终结果。 */ int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; dis[i][j] = g[i][j]; &#125; // floyd 求任意两点间的最短路径 for(int k = 1; k &lt;= n; k++) // 枚举中间点 for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n;j++) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); // 判断负环 for(int i =1; i &lt;= n; i++) &#123; if(dis[i][i] &lt; 0) cout&lt;&lt;&quot;存在负环&quot;; break; &#125; return 0;&#125; DijkstraFeatures只适用于正权边 思想是贪心的思想 朴素版 $Dijkstra$ 适合稠密图 朴素Dijkstra思路集合S为已经确定最短路径的点集。 初始化距离： $1$ 号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。 循环 $n$ 次，每一次将集合 $S$ 之外距离最短 $X$ 的点加入到 $S$ 中去（这里的距离最短指的是距离 $1$ 号点最近。点 $X$ 的路径一定最短，基于贪心，严格证明待看）。然后用点 $X$ 更新 $X$ 邻接点的距离。 时间复杂度分析寻找路径最短的点：$O(n^2)$ 加入集合 $S$：$O(n)$ 更新距离：$O(m)$ 所以总的时间复杂度为 $O(n^2)$ Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510;int g[N][N];//邻接矩阵/*struct node&#123; int id, w;&#125;vector&lt;node&gt; g[N];//邻接表*/int dist[N];bool visited[N]; // 依据访问过与否将所有节点分成两个部分(集合)int n, m;int dijkstra()&#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 1; i &lt;= n; i++)&#123; // 确定集合中距离初始节点最近的点 t int t = -1; for(int j = 1; j &lt;= n; j++) &#123; if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; visited[t] = true; // 加入 S 集合 // 从 t 出发，更新相邻点的 dist for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); //dist[j] = min(dist[j], dist[t] + g[t][j].w); &#125; if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof(g)); while (m--) &#123; int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); g[x][y] = min(g[x][y], c); // 因为有重边，所以只保留最短边 &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125; 堆优化 Dijkstra 任何场景均适合 思路堆优化版的 $Dijkstra$ 是对朴素版 $Dijkstra$ 进行了优化，在朴素版 $Dijkstra$ 中时间复杂度最高的寻找距离最短的点 $O(n^2)$ 可以使用最小堆优化。 1 号点的距离初始化为零，其他点初始化成无穷大。 将一号点放入堆中。 不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版 $dijkstra$ 找到 $S$ 外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。 时间复杂度分析寻找路径最短的点：$O(n)$ 加入集合S：$O(n)$ 更新距离：$O(mlog_n)$ 所以总的时间复杂度为 $O(m{log}_n)$ Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 150010;struct node&#123; int y, w;&#125;;vector&lt;node&gt; g[N];int dist[N];bool st[N]; // 如果为true说明这个点的最短路径已经确定int n, m;void add(int x, int y, int c)&#123; g[x].push_back((node)&#123;y, c&#125;);&#125;int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 q.push(&#123; 0, 1 &#125;); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(!q.empty()) &#123; PII tmp = q.top(); // 取不在集合S中距离最短的点 q.pop(); int cur = tmp.second, d = tmp.first; if(st[cur]) continue; st[cur] = true; // 加入集合 S 中 for(int i = 0; i &lt; g[cur].size(); i++) &#123; int id = g[cur][i].y, w = g[cur][i].w; if(dist[id] &gt; d + w) &#123; dist[id] = d + w; q.push(&#123; dist[id], id &#125;); &#125; &#125; &#125; if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (m--) &#123; int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); add(x, y, c); &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125; 链式前向星写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 150010;int h[N], e[N], ne[N], idx;int w[N]; // 用来存权重int dist[N];bool st[N]; // 如果为true说明这个点的最短路径已经确定int n, m;// 稀疏图用链式前向星来存void add(int x, int y, int c)&#123; w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++;&#125;int dijkstra()&#123; memset(dist, 0x3f, sizeof(dist)); dist[0] = 1; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 q.push(&#123; 0, 1 &#125;); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(!q.empty()) &#123; PII k = q.top(); // 取不在集合S中距离最短的点 q.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; // 加入集合 S 中 for(int i = h[ver]; i != -1; i = ne[i]) &#123; int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) &#123; dist[j] = distance + w[i]; q.push(&#123; dist[j], j &#125;); &#125; &#125; &#125; if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];&#125;int main()&#123; memset(h, -1, sizeof(h)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (m--) &#123; int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); add(x, y, c); &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"图笔记 Ⅰ(性质)","slug":"图笔记-Ⅰ(性质)","date":"2021-04-24T09:59:59.776Z","updated":"2021-04-18T12:51:35.663Z","comments":true,"path":"2021/04/24/图笔记-Ⅰ(性质)/","link":"","permalink":"https://ender-003.github.io/2021/04/24/%E5%9B%BE%E7%AC%94%E8%AE%B0-%E2%85%A0(%E6%80%A7%E8%B4%A8)/","excerpt":"","text":"图的概念基本概念图 (Graph) 是一个二元组 $G=(V(G), E(G))$ 。其中 $V(G)$ 是非空集，称为 点集 (Vertex set) ，对于 $V$ 中的每个元素，我们称其为 顶点 (Vertex) 或 节点 (Node) ，简称 点 ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 边集 (Edge set) 。 常用 $G=(V,E)$ 表示图。 当 $V,E$ 都是有限集合时，称 $G$ 为 有限图 。 当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 无限图 。 图有多种，包括 无向图 (Undirected graph) ， 有向图 (Directed graph) ， 混合图 (Mixed graph) 等 若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 无向边 (Undirected edge) ，简称 边 (Edge) ，其中 $u, v \\in V$ 。设 $e = (u, v)$，则 $u$ 和 $v$ 称为 $e$ 的 端点 (Endpoint) 。 若 $G 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \\to v$ ，称作 有向边 (Directed edge) 或 弧 (Arc) ，在不引起混淆的情况下也可以称作 边 (Edge) 。设 $e = u \\to v$ ，则此时 $u$ 称为 $e$ 的 起点 (Tail) ， $v$ 称为 $e$ 的 终点 (Head) ，起点和终点也称为 $e$ 的 端点 (Endpoint) 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $u$ 的直接后继。 若 $G$ 为混合图，则 $E$ 中既有向边，又有无向边。 若 $G$ 的每条边 $e_k = (u_k,v_k)$ 都被赋予一个数作为该边的 权 ，则称 $G$ 为 赋权图 。如果这些权都是正实数，就称 $G$ 为 正权图 。 图 $G$ 的点数 $\\left| V(G) \\right|$ 也被称作图 $G$ 的 阶 (Order) 。 形象地说，图是由若干点以及连接点与点的边构成的。","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"","slug":"图的存储方法","date":"2021-04-24T09:59:59.773Z","updated":"2021-03-27T07:53:11.640Z","comments":true,"path":"2021/04/24/图的存储方法/","link":"","permalink":"https://ender-003.github.io/2021/04/24/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"图的概念基本概念图 (Graph) 是一个二元组 $G=(V(G),E(G))$ 。其中 $V(G)$ 是非空集，称为 点集 (Vertex set) ，对于 VV 中的每个元素，我们称其为 顶点 (Vertex) 或 节点 (Node) ，简称 点 ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 边集 (Edge set) 。 常用 $G=(V,E)$ 表示图。 当 $V,E$ 都是有限集合时，称 $G$ 为 有限图 。 当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 无限图 。 图有多种，包括 无向图 (Undirected graph) ， 有向图 (Directed graph) ， 混合图 (Mixed graph) 等 若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 无向边 (Undirected edge) ，简称 边 (Edge) ，其中 $u, v \\in V$ 。设 $e = (u, v)$ ，则 $u$ 和 $v$ 称为 $e$ 的 端点 (Endpoint) 。 若 $G$ 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \\to v$ ，称作 有向边 (Directed edge) 或 弧 (Arc) ，在不引起混淆的情况下也可以称作 边 (Edge) 。设 $e = u \\to v$ ，则此时 $u$ 称为 $e$ 的 起点 (Tail) ， $v$ 称为 $e$ 的 终点 (Head) ，起点和终点也称为 $e$ 的 端点 (Endpoint) 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $u$ 的直接后继。","categories":[],"tags":[]},{"title":"How To Use Free V*N","slug":"How-To-Use-Free-VN","date":"2021-02-25T13:25:00.000Z","updated":"2021-04-02T05:21:50.446Z","comments":true,"path":"2021/02/25/How-To-Use-Free-VN/","link":"","permalink":"https://ender-003.github.io/2021/02/25/How-To-Use-Free-VN/","excerpt":"","text":"说在前面: 不是万不得已不要用梯子!还有, 本文方法只适用于Chrome浏览器或Edge(新版)浏览器, 没有的话可以去网上下载一个, 首推Chrome 以下为正文: 如何免费珂学上网首先上两个免费V*N的链接 Astar (有免费节点, 需注册(最近好像又不需要了), 较稳定, 推荐Canada节点) VeePN (有免费节点, 无需注册, 稳定性较上一个较差, 推荐Singapore节点) 然后你就会发现这个网站打不开, 这时就需要一个可以链接Google的小梯子了(作者已经准备好了) Link 提取码：a868 下载以后把文件夹放在一个专用的文件夹里然后去浏览器安装 这里安装过程以Chrome浏览器为例:点击： 右上角三个点 设置 左下角“扩展程序” 右上角“开发者模式” 左上“加载已解压的扩展程序” 选择刚下载下来的“谷歌访问助手”文件夹 然后等谷歌访问助手链接主服务器成功，点击上方那两个梯子的下载链接，再点击“添加至Chrome”，等下载完毕，自己选择节点就好啦","categories":[],"tags":[{"name":"颓废","slug":"颓废","permalink":"https://ender-003.github.io/tags/%E9%A2%93%E5%BA%9F/"}]},{"title":"分治笔记","slug":"分治笔记","date":"2020-12-19T09:00:00.000Z","updated":"2020-12-26T07:22:29.167Z","comments":true,"path":"2020/12/19/分治笔记/","link":"","permalink":"https://ender-003.github.io/2020/12/19/%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"分治1. 归并排序代码: 123456789101112131415161718192021222324252627282930#define N 10000010int num[N];int tmp[N]; //临时数组void merge(int l,int mid,int r)&#123; int i = l, j = mid + 1; int k = 0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(num[i]&lt;=num[j]) tmp[k++] = num[i++]; else tmp[k++] = num[j++]; &#125; while(i&lt;=mid) tmp[k++] = num[i++]; while(j&lt;=r) tmp[k++] = num[j++]; for (int f = 0; f &lt; k;f++) num[l + f] = tmp[f];&#125;//合并void merge_sort(int l,int r)&#123; if(l==r) return; int mid = (l + r) / 2; //中间数的位置 merge_sort(l, mid); merge_sort(mid + 1, r); //分治 merge(l, mid, r);&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"个人收录的颓废小游戏合集","slug":"个人收录颓废小游戏合集","date":"2020-12-05T09:12:00.000Z","updated":"2021-03-05T04:34:17.364Z","comments":true,"path":"2020/12/05/个人收录颓废小游戏合集/","link":"","permalink":"https://ender-003.github.io/2020/12/05/%E4%B8%AA%E4%BA%BA%E6%94%B6%E5%BD%95%E9%A2%93%E5%BA%9F%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"某小游戏合集网站 MC Classic网页版(你没看错,就是网页版) 小霸王游戏(网页)合集 超级玛丽 贪吃蛇 尺规作图 “我”的二次元少女形象 你画我猜 大型像素枪战 小黑屋 多人联机坦克大作战(diep.io) 多人联机舰船大作战(和diep.io很像) 打飞字 slay.one 名字竞技场(很好玩!!!) 膜$ \\textbf{S}\\color{Red}iyuan$ 太空公司 多人联机跳跳大作战 贪吃陀螺 yorg.io(塔防) 猫国建设者 吃鸡 流浪日记(这个似乎挂了) 工匠 见缝插针","categories":[],"tags":[{"name":"颓废","slug":"颓废","permalink":"https://ender-003.github.io/tags/%E9%A2%93%E5%BA%9F/"}]},{"title":"搜索笔记","slug":"搜索笔记","date":"2020-11-28T06:12:00.000Z","updated":"2020-12-20T12:33:36.811Z","comments":true,"path":"2020/11/28/搜索笔记/","link":"","permalink":"https://ender-003.github.io/2020/11/28/%E6%90%9C%E7%B4%A2%E7%AC%94%E8%AE%B0/","excerpt":"","text":"搜索 搜索，也就是对状态空间进行枚举。通过穷尽所有的可能，来找到最优解，或者统计合法解的个数。 搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。 搜索是一些高级算法的基础，在 OI 中，纯粹的搜索往往也是得到 部分分 的强有力的手段，但可以通过纯粹的搜索拿到满分的题目非常少的。 搜索的策略：深度、广度 重要的概念： 状态空间：所有合理状态的集合 搜索树：从初始状态出发能访问的所有状态节点及对应路径构成的一棵树 状态：各种属性（位置、步数、和、路径记录[有时可以用全局变量记录]） 初始状态：状态的各种属性为初始值 目标状态：一般是状态的某个属性满足一定条件下的状态，比如达到指定位置、和达到一定值 可行解：所有目标状态都是可行解 最优解：目标状态中满足最优性（某属性最小、最大） 解集：有时要求输出一个最优状态、有时要求输出所有的目标状态，有时要求输出任意一个目标状态 搜索的步骤： 深搜：从上往下，到底回溯，每次向下搜索都将之前一步的状态保存下来（入栈），特别地，如果用函数递归实现，除全局变量外，不需要手动去保存状态。 广搜：按层遍历，适用最优，队列中按层保存着每一层的状态。 搜索的优化： 剪枝 回溯 记忆化 代码框架：DFS123456789101112131415161718192021全局状态变量void dfs(当前状态)&#123; if(当前状态是目标状态) // 判断 进行相应处理（计数、输出当前解、更新最优解、退出返回等） // 扩展 for(所有可行的新状态)&#123; if(新状态没有访问过 &amp;&amp; 需要访问)&#123; // 可行性剪枝、最优性剪枝、重复性剪枝 标记 dfs(新状态) 取消标记 //回溯 &#125; &#125;&#125;int main()&#123; ... dfs(初始状态); ...&#125; BFS12345678910111213141516全局状态变量定义状态队列void BFS()&#123; 初始状态入队 while(队列不为空)&#123; 取出队首状态作为当前状态 if(当前状态是目标状态) 进行相应处理（输出当前解、更新最优解、退出返回等） else for(所有可行的新状态)&#123; if(新状态没有访问过 &amp;&amp; 需要访问)&#123; // 可行性剪枝、最优性剪枝、重复性剪枝 新状态入队 &#125; &#125;&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"课堂笔记整合","slug":"课堂笔记整合","date":"2020-11-28T06:12:00.000Z","updated":"2020-12-20T12:23:03.431Z","comments":true,"path":"2020/11/28/课堂笔记整合/","link":"","permalink":"https://ender-003.github.io/2020/11/28/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88/","excerpt":"","text":"搜索 分治","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-05T05:33:00.000Z","updated":"2020-10-07T08:00:27.181Z","comments":true,"path":"2020/10/05/hello-world/","link":"","permalink":"https://ender-003.github.io/2020/10/05/hello-world/","excerpt":"","text":"Hello World这是我的第一篇文章 以此纪念Blog正式建成","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://ender-003.github.io/tags/Hello-World/"}]}],"categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"},{"name":"颓废","slug":"颓废","permalink":"https://ender-003.github.io/tags/%E9%A2%93%E5%BA%9F/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://ender-003.github.io/tags/Hello-World/"}]}