{"meta":{"title":"Ender_'s Blog","subtitle":"","description":"","author":"Ender","url":"https://ender-003.github.io","root":"/"},"pages":[],"posts":[{"title":"LaTeX/KaTeX语法集合 --- By 离散小波变换°","slug":"LaTeX,KaTeX","date":"2021-05-22T08:27:00.000Z","updated":"2021-05-22T08:28:56.848Z","comments":true,"path":"2021/05/22/LaTeX,KaTeX/","link":"","permalink":"https://ender-003.github.io/2021/05/22/LaTeX,KaTeX/","excerpt":"","text":"包含内容：语法/技巧/注意事项。 https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan https://www.luogu.com.cn/blog/IowaBattleship/latex-ru-men https://www.luogu.com.cn/blog/luogu/how-to-use-markdown https://www.luogu.com.cn/blog/93465/markdown-yu-latex-chang-yong-yu-fa-zheng-li https://katex.org/docs/supported.html#math-operators https://www.luogu.com.cn/blog/McHf/katex-gong-shi-tai-quan https://www.luogu.com.cn/paste/hs3jg81l https://www.luogu.com.cn/paste/wmm62fg7","categories":[],"tags":[{"name":"合集","slug":"合集","permalink":"https://ender-003.github.io/tags/%E5%90%88%E9%9B%86/"}]},{"title":"最小生成树","slug":"最小生成树","date":"2021-05-22T06:23:00.000Z","updated":"2021-05-22T08:26:15.532Z","comments":true,"path":"2021/05/22/最小生成树/","link":"","permalink":"https://ender-003.github.io/2021/05/22/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"引入通过前面的学习，对于含有 n 个顶点的连通图来说可能包含有多种生成树，例如图 1 所示： 图 1 连通图的生成树 图 1 中的连通图和它相对应的生成树，可以用于解决实际生活中的问题：假设A、B、C 和 D 为 4 座城市，为了方便生产生活，要为这 4 座城市建立通信。对于 4 个城市来讲，本着节约经费的原则，只需要建立 3 个通信线路即可，就如图 1（b）中的任意一种方式。 在具体选择采用（b）中哪一种方式时，需要综合考虑城市之间间隔的距离，建设通信线路的难度等各种因素，将这些因素综合起来用一个数值表示，当作这条线路的权值。 图 2 无向网 假设通过综合分析，城市之间的权值如 $图2(a)$ 所示，对于 $(b)$ 的方案中，选择权值总和为 7 的两种方案最节约经费。 这就是本节要讨论的最小生成树的问题，简单得理解就是给定一个带有权值的连通图（连通网），如何从众多的生成树中筛选出权值总和最小的生成树，即为该图的最小生成树。 给定一个连通网，求最小生成树的方法有： $Prim$ 算法和 $Kruskal$ 算法。 Prim算法 一种贪心的算法，适用于稠密图，时间复杂度 $O(n^2)$ 。 核心思想：每次挑一条与当前集合相连的最短边。 原理普里姆算法在找最小生成树时，将顶点分为两类，一类是在查找的过程中已经包含在树中的（假设为 A 类），剩下的是另一类（假设为 B 类），并且 $Prim$ 算法总是维护最小生成树的一部分，类似 $Dijkstra$ 算法。 对于给定的连通网，起始状态全部顶点都归为 B 类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A 类；然后找出 B 类中到 A 类中的顶点之间权值最小的顶点，将之从 B 类移至 A 类，如此重复，直到 B 类中没有顶点为止。所走过的顶点和边就是该连通图的最小生成树。 切分定理 ❓为什么每次选最小边是正确的呢 Prim 算法是基于切分定理的。 切分（Cut）：把图中的节点分为两部分，称为一个切分。下图有个切分 $C = (S, T)，S = {A, B, D}，T = {C, E}$ 横切边（ $Crossing Edge$ ）：如果一个边的两个顶点，分别属于切分的两部分，这个边称为横切边。比如上图的边 BC、BE、DE 就是横切边。 切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树。 证明：假设原图切分后的两个部分各自组成了一棵最小生成子树，那么在这两个部分之间加入任意一条边都可以将形成整个图的生成树。很容易得知，加入所有横切边中权值最小的边就可以形成最小生成树。 算法过程例如，通过普里姆算法查找图 2（a）的最小生成树的步骤为： 假如从顶点A出发，顶点 B、C、D 到顶点 A 的权值分别为 2、4、2，所以，对于顶点 A 来说，顶点 B 和顶点 D 到 A 的权值最小，假设先找到的顶点 B： 继续分析顶点 C 和 D，顶点 C 到 B 的权值为 3，到 A 的权值为 4；顶点 D 到 A 的权值为 2，到 B 的权值为无穷大（如果之间没有直接通路，设定权值为无穷大）。所以顶点 D 到 A 的权值最小： 最后，只剩下顶点 C，到 A 的权值为 4，到 B 的权值和到 D 的权值一样大，为 3。所以该连通图有两个最小生成树： 示例代码具体实现代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*S:当前已经在联通块中的所有点的集合1. dist[i] = inf2. for n 次 t&lt;-S外离S最近的点 利用t更新S外点到S的距离 st[t] = truen次迭代之后所有点都已加入到S中联系：Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离*/#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int n, m;int g[N][N], dist[N];//邻接矩阵存储所有边//dist存储其他点到S的距离bool st[N];int prim() &#123; //如果图不连通返回INF, 否则返回res memset(dist, INF, sizeof dist); int res = 0;//总权值 for(int i = 0; i &lt; n; i++) &#123; int t = -1; for(int j = 1; j &lt;= n; j++) if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; //寻找离集合S最近的点 if(i &amp;&amp; dist[t] == INF) return INF; //判断是否连通，有无最小生成树 if(i) res += dist[t]; //cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; res &lt;&lt; endl; st[t] = true; //更新最新S的权值和 for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); &#125; return res;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; int u, v, w; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(i ==j) g[i][j] = 0; else g[i][j] = INF; while(m--) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u][v] = g[v][u] = min(g[u][v], w); &#125; int t = prim(); if(t == INF) puts(&quot;impossible&quot;); else cout &lt;&lt; t &lt;&lt; endl;&#125; 时间复杂度普里姆算法的运行效率只与连通网中包含的顶点数相关，而和网所含的边数无关。所以普里姆算法适合于解决边稠密的网，该算法运行的时间复杂度为：O(n^2)O(n2)。 如果连通网中所含边的绸密度不高，则建议使用克鲁斯卡尔算法求最小生成树。 堆优化的Prim算法 堆 $prime$ 的优化，主要从for循环里的两个for循环下手： 第一个for循环是找最小值，方式使用堆进行优化； 对第二个for循环，用邻接表进行操作。 思路如果使用二叉堆，prim算法的复杂度能降到O(E log V)。 之前实现的这个Prim算法，是用邻接矩阵表示图。而堆优化的Prim算法，将用邻接表来表示图，且使用最小堆来寻找，连接MST集合和非MST集合的边中，最小权值的那条边。 基本思想：基本思想和原Prim算法大体相同，但此算法是，根据邻接表，通过广度优先遍历（BFS）来遍历所有节点，遍历的总操作为O(V+E)次数。同时使用最小堆存储非MST集合中的节点，每次遍历时用最小堆来选择节点。最小堆操作的时间复杂度为O(LogV)。 基本步骤 创建一个大小为V的最小堆，V是图的节点个数。最小堆的每个元素，存储的是节点id和节点的key值。 初始化时，让堆的第一个元素作为最小生成树的根节点，赋值根节点的key值为0。其余节点的key值赋值为无穷大。 3.只要最小堆不为空，就重复以下步骤： (i)从最小堆中，抽取最小key值的节点，作为u。 (ii)对于u的每个邻接点v，检查v是否在最小堆中（即还没有加入到MST中）。如果v在最小堆中，且v的key值是大于边u-v的权值时，就更新v的key值为边u-v的权值。 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 510, MAXM = 2 * 1e5 + 10, INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; PII;int h[MAXM], e[MAXM], w[MAXM], ne[MAXM], idx;bool vis[MAXN];int n, m;void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;int Prim()&#123; memset(vis, false, sizeof vis); int sum = 0, cnt = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; q.push(&#123;0, 1&#125;); while (!q.empty()) &#123; auto t = q.top(); q.pop(); int ver = t.second, dst = t.first; if (vis[ver]) continue; vis[ver] = true, sum += dst, ++cnt; for (int i = h[ver]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!vis[j]) &#123; q.push(&#123;w[i], j&#125;); &#125; &#125; &#125; if (cnt != n) return INF; return sum;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for (int i = 0; i &lt; m; ++i) &#123; int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; add(a, b, w); add(b, a, w); &#125; int t = Prim(); if (t == INF) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; else cout &lt;&lt; t &lt;&lt; endl; &#125; 时间复杂度使用二叉堆，prim算法的复杂度降到了 $O(E log V)$ 。 克鲁斯卡尔算法(Kruskal算法) 适用于稀疏图，时间复杂度 O(mlogm)O(mlogm)。 核心思想：从小到大挑不多余的边。 之前介绍了求最小生成树之普里姆算法。该算法从顶点的角度为出发点，时间复杂度为O(n^2)O(n2)，更适合与解决边的绸密度更高的连通网。 本节所介绍的克鲁斯卡尔算法，从边的角度求网的最小生成树，时间复杂度为O(E\\log E)O(ElogE)。和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树。 对于任意一个连通网的最小生成树来说，在要求总的权值最小的情况下，最直接的想法就是将连通网中的所有边按照权值大小进行升序排序，从小到大依次选择。 由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点： 生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路； 对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点。 连接 n 个顶点在不产生回路的情况下，只需要 n-1 条边。 思路所以克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。 判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。 过程假设遍历到一条由顶点 A 和 B 构成的边，而顶点 A 和顶点 B 标记不同，此时不仅需要将顶点 A 的标记更新为顶点 B 的标记，还需要更改所有和顶点 A 标记相同的顶点的标记，全部改为顶点 B 的标记。 图 1 连通网 例如，使用克鲁斯卡尔算法找图 1 的最小生成树的过程为： 首先，在初始状态下，对各顶点赋予不同的标记（用颜色区别），如下图所示： （1） 对所有边按照权值的大小进行排序，按照从小到大的顺序进行判断，首先是（1，3），由于顶点 1 和顶点 3 标记不同，所以可以构成生成树的一部分，遍历所有顶点，将与顶点 3 标记相同的全部更改为顶点 1 的标记，如（2）所示： （2） 其次是（4，6）边，两顶点标记不同，所以可以构成生成树的一部分，更新所有顶点的标记为： （3） 其次是（2，5）边，两顶点标记不同，可以构成生成树的一部分，更新所有顶点的标记为： （4） 然后最小的是（3，6）边，两者标记不同，可以连接，遍历所有顶点，将与顶点 6 标记相同的所有顶点的标记更改为顶点 1 的标记： （5） 继续选择权值最小的边，此时会发现，权值为 5 的边有 3 个，其中（1，4）和（3，4）各自两顶点的标记一样，如果连接会产生回路，所以舍去，而（2，3）标记不一样，可以选择，将所有与顶点 2 标记相同的顶点的标记全部改为同顶点 3 相同的标记： （6） 当选取的边的数量相比与顶点的数量小 1 时，说明最小生成树已经生成。所以最终采用克鲁斯卡尔算法得到的最小生成树为（6）所示。 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = 4e5 + 10, INF = 0x3f3f3f3f;int n, m;int p[N];struct Edge &#123; int a, b, w; bool operator&lt;(const Edge &amp;e) const &#123; return w &lt; e.w; &#125;&#125; es[M];int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int kruskal() &#123; int cnt = 0, res = 0; sort(es, es + m); for (int i = 1; i &lt;= n; i++) p[i] = i; for (int i = 0; i &lt; m; i++) &#123; int a = es[i].a, b = es[i].b, w = es[i].w; a = find(a), b = find(b); if (a != b) &#123; p[a] = b; res += w; cnt++; &#125; &#125; if (cnt &lt; n - 1) return INF; else return res;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); es[i] = &#123;a, b, w&#125;; &#125; int t = kruskal(); if (t == INF) cout &lt;&lt; &quot;impossible&quot;; else cout &lt;&lt; t;&#125; Copy 时间复杂度分析排序：O(E\\log E)O(ElogE)，采用并查集选边合并：O(E\\alpha (V))O(E**α(V))，总时间复杂度：O(E\\log E)O(ElogE) 对比两种最小生成树算法Kruskal算法此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 1. 把图中的所有边按代价从小到大排序； 2. 把图中的n个顶点看成独立的n棵树组成的森林； 3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。 Prim算法此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为V；初始令集合u={s},v=V−u; 在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"图笔记 Ⅱ(存储&便利)","slug":"图笔记- Ⅱ","date":"2021-04-24T09:59:59.778Z","updated":"2021-04-24T08:29:44.122Z","comments":true,"path":"2021/04/24/图笔记- Ⅱ/","link":"","permalink":"https://ender-003.github.io/2021/04/24/%E5%9B%BE%E7%AC%94%E8%AE%B0-%20%E2%85%A1/","excerpt":"","text":"存储1. 直接存边使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权） Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct Edge &#123; int u, v, w; // 一条边的 起点、终点、权值&#125;;int n, m;vector&lt;Edge&gt; e;vector&lt;bool&gt; vis;bool find_edge(int u, int v) &#123; for (int i = 1; i &lt;= m; ++i) &#123; if (e[i].u == u &amp;&amp; e[i].v == v) &#123; return true; &#125; &#125; return false;&#125;void dfs(int u) &#123; if (vis[u]) return; vis[u] = true; for (int i = 1; i &lt;= m; ++i) &#123; if (e[i].u == u) &#123; dfs(e[i].v); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; vis.resize(n + 1, false); e.resize(m + 1); for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v; return 0;&#125; 复杂度查询是否存在某条边： $O(m)$ 。 遍历一个点的所有出边： $O(m)$ 。 遍历整张图： $O(nm)$ 。 空间复杂度： $O(m)$ 。 应用由于直接存边的遍历效率低下，一般不用于遍历图。 在 $Kruskal$ 算法中，由于需要将边按边权排序，需要直接存边。 在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。 2. 邻接矩阵使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 uu 到 vv 的边，为 0 表示不存在。 如果是带边权的图，可以在 adj[u][v] 中存储 uu 到 vv 的边的边权，0 表示没有连接，其他值表示权重。 如果是无向图，则将一条无向边拆成两条方向相反的边即可。（所谓的「无向」，也就等同于「双向」） Code:123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5+5;int n, m;bool vis[N];bool adj[N][N];bool find_edge(int u, int v) &#123; return adj[u][v]; &#125;void dfs(int u) &#123; if (vis[u]) return; vis[u] = true; for (int v = 1; v &lt;= n; ++v) &#123; if (adj[u][v]) &#123; dfs(v); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; fill_n(vis, N, false); fill_n(adj, N*N, false); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u][v] = true; // u-&gt;v 有条单向边 // 如果是双向边 // adj[u][v] = adj[v][u] = true; &#125; return 0;&#125; 复杂度查询是否存在某条边： $O(1)$ 。 遍历一个点的所有出边： $O(n)$ 。 遍历整张图： $O(n^2)$ 。 空间复杂度： $O(n^2)$ 。 应用邻接矩阵只适用于没有重边（或重边可以忽略）的情况。 其最显著的优点是可以 $O(1)$ 查询一条边是否存在。 由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会 在稠密图上使用邻接矩阵。并且，在稠密图上使用邻接矩阵的运行效率远高于邻接表，这是因为 CPU 中顺序访问的速度是远高于随机访问的（缓存命中）。 遍历深度优先遍历1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e5+5;int n, m;bool vis[N]; // 标记是否访问过bool adj[N][N]; // 邻接矩阵存图void dfs(int u) &#123; vis[u] = true; for (int v = 1; v &lt;= n; ++v) &#123; if (adj[u][v] &amp;&amp; !vis[u]) &#123; // 有边，并且没访问过，访问 dfs(v); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; fill_n(vis, N, false); fill_n(adj, N*N, false); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; adj[u][v] = true; // u-&gt;v 有条单向边 // 如果是双向边 // adj[u][v] = adj[v][u] = true; &#125; dfs(1); return 0;&#125; 广度优先遍历1234567891011121314151617const int N = 1e5+5;int n, m;bool vis[N]; // 标记是否访问过bool adj[N][N]; // 邻接矩阵存图void bfs(int s) &#123; queue&lt;int&gt; q; q.push(s); while(!q.empty()) &#123; int k = q.front(); q.pop(); cout &lt;&lt; k &lt;&lt; &quot; &quot;; for(int i = 1; i &lt;= n; i++) &#123; if (adj[k][i] &amp;&amp; !vis[i]) // 有边，并且没访问过，访问 q.push(i); &#125; &#125;&#125; 最短路FloydFeatures 时间复杂度是 $O(n^3)$ ，因此，只适用于 $n &lt; 500$ 的这种结点数不多的情况。 它是多源最短路的，可以求出任何两点之间的最短路。 支持负边权 能够判断图中是否存在负回路 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int N=510;int g[N][N];int dis[N][N]; // dis[i][j]: i-&gt;j 最短距离 /*证明：定义 dis[i][j][k] 表示从 i 到 j 的可以经过 1~k 号结点的最短路径，此问题可以被分解为两个子问题（1）不经过 k 号结点，即 dis[i][j][k-1]（2）经过 k 号结点，即 dis[i][k][k-1]+dis[k][j][k-1];因此，有：dis[i][j][k] = min(dis[i][j][k-1], dis[i][k][k-1], dis[k][j][k-1]);上式中第三维 k 可以省略，则有： dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);虽然 i,j,k 的顺序不保证，导致上式中 dis[i][k] 和 dis[k][j] 可能是已经被更新过的 dis[i][k][k] 和 dis[k][j][k] 了，但是这并不影响其正确性。因为更新后的值一定会变得更小，不会影响最终结果。 */ int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; g[i][j]; dis[i][j] = g[i][j]; &#125; // floyd 求任意两点间的最短路径 for(int k = 1; k &lt;= n; k++) // 枚举中间点 for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n;j++) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); // 判断负环 for(int i =1; i &lt;= n; i++) &#123; if(dis[i][i] &lt; 0) cout&lt;&lt;&quot;存在负环&quot;; break; &#125; return 0;&#125; DijkstraFeatures只适用于正权边 思想是贪心的思想 朴素版 $Dijkstra$ 适合稠密图 朴素Dijkstra思路集合S为已经确定最短路径的点集。 初始化距离： $1$ 号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。 循环 $n$ 次，每一次将集合 $S$ 之外距离最短 $X$ 的点加入到 $S$ 中去（这里的距离最短指的是距离 $1$ 号点最近。点 $X$ 的路径一定最短，基于贪心，严格证明待看）。然后用点 $X$ 更新 $X$ 邻接点的距离。 时间复杂度分析寻找路径最短的点：$O(n^2)$ 加入集合 $S$：$O(n)$ 更新距离：$O(m)$ 所以总的时间复杂度为 $O(n^2)$ Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510;int g[N][N];//邻接矩阵/*struct node&#123; int id, w;&#125;vector&lt;node&gt; g[N];//邻接表*/int dist[N];bool visited[N]; // 依据访问过与否将所有节点分成两个部分(集合)int n, m;int dijkstra()&#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 1; i &lt;= n; i++)&#123; // 确定集合中距离初始节点最近的点 t int t = -1; for(int j = 1; j &lt;= n; j++) &#123; if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; visited[t] = true; // 加入 S 集合 // 从 t 出发，更新相邻点的 dist for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); //dist[j] = min(dist[j], dist[t] + g[t][j].w); &#125; if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof(g)); while (m--) &#123; int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); g[x][y] = min(g[x][y], c); // 因为有重边，所以只保留最短边 &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125; 堆优化 Dijkstra 任何场景均适合 思路堆优化版的 $Dijkstra$ 是对朴素版 $Dijkstra$ 进行了优化，在朴素版 $Dijkstra$ 中时间复杂度最高的寻找距离最短的点 $O(n^2)$ 可以使用最小堆优化。 1 号点的距离初始化为零，其他点初始化成无穷大。 将一号点放入堆中。 不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版 $dijkstra$ 找到 $S$ 外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。 时间复杂度分析寻找路径最短的点：$O(n)$ 加入集合S：$O(n)$ 更新距离：$O(mlog_n)$ 所以总的时间复杂度为 $O(m{log}_n)$ Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 150010;struct node&#123; int y, w;&#125;;vector&lt;node&gt; g[N];int dist[N];bool st[N]; // 如果为true说明这个点的最短路径已经确定int n, m;void add(int x, int y, int c)&#123; g[x].push_back((node)&#123;y, c&#125;);&#125;int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 q.push(&#123; 0, 1 &#125;); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(!q.empty()) &#123; PII tmp = q.top(); // 取不在集合S中距离最短的点 q.pop(); int cur = tmp.second, d = tmp.first; if(st[cur]) continue; st[cur] = true; // 加入集合 S 中 for(int i = 0; i &lt; g[cur].size(); i++) &#123; int id = g[cur][i].y, w = g[cur][i].w; if(dist[id] &gt; d + w) &#123; dist[id] = d + w; q.push(&#123; dist[id], id &#125;); &#125; &#125; &#125; if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (m--) &#123; int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); add(x, y, c); &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125; 链式前向星写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 150010;int h[N], e[N], ne[N], idx;int w[N]; // 用来存权重int dist[N];bool st[N]; // 如果为true说明这个点的最短路径已经确定int n, m;// 稀疏图用链式前向星来存void add(int x, int y, int c)&#123; w[idx] = c; // 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中 e[idx] = y; // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并 ne[idx] = h[x]; // 标记st为true，所以下一次弹出3+x会continue不会向下执行。 h[x] = idx++;&#125;int dijkstra()&#123; memset(dist, 0x3f, sizeof(dist)); dist[0] = 1; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时 // 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 q.push(&#123; 0, 1 &#125;); // 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序 while(!q.empty()) &#123; PII k = q.top(); // 取不在集合S中距离最短的点 q.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; // 加入集合 S 中 for(int i = h[ver]; i != -1; i = ne[i]) &#123; int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) &#123; dist[j] = distance + w[i]; q.push(&#123; dist[j], j &#125;); &#125; &#125; &#125; if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];&#125;int main()&#123; memset(h, -1, sizeof(h)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while (m--) &#123; int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); add(x, y, c); &#125; cout &lt;&lt; dijkstra() &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"图笔记 Ⅰ(性质)","slug":"图笔记-Ⅰ(性质)","date":"2021-04-24T09:59:59.776Z","updated":"2021-04-18T12:51:35.663Z","comments":true,"path":"2021/04/24/图笔记-Ⅰ(性质)/","link":"","permalink":"https://ender-003.github.io/2021/04/24/%E5%9B%BE%E7%AC%94%E8%AE%B0-%E2%85%A0(%E6%80%A7%E8%B4%A8)/","excerpt":"","text":"图的概念基本概念图 (Graph) 是一个二元组 $G=(V(G), E(G))$ 。其中 $V(G)$ 是非空集，称为 点集 (Vertex set) ，对于 $V$ 中的每个元素，我们称其为 顶点 (Vertex) 或 节点 (Node) ，简称 点 ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 边集 (Edge set) 。 常用 $G=(V,E)$ 表示图。 当 $V,E$ 都是有限集合时，称 $G$ 为 有限图 。 当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 无限图 。 图有多种，包括 无向图 (Undirected graph) ， 有向图 (Directed graph) ， 混合图 (Mixed graph) 等 若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 无向边 (Undirected edge) ，简称 边 (Edge) ，其中 $u, v \\in V$ 。设 $e = (u, v)$，则 $u$ 和 $v$ 称为 $e$ 的 端点 (Endpoint) 。 若 $G 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \\to v$ ，称作 有向边 (Directed edge) 或 弧 (Arc) ，在不引起混淆的情况下也可以称作 边 (Edge) 。设 $e = u \\to v$ ，则此时 $u$ 称为 $e$ 的 起点 (Tail) ， $v$ 称为 $e$ 的 终点 (Head) ，起点和终点也称为 $e$ 的 端点 (Endpoint) 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $u$ 的直接后继。 若 $G$ 为混合图，则 $E$ 中既有向边，又有无向边。 若 $G$ 的每条边 $e_k = (u_k,v_k)$ 都被赋予一个数作为该边的 权 ，则称 $G$ 为 赋权图 。如果这些权都是正实数，就称 $G$ 为 正权图 。 图 $G$ 的点数 $\\left| V(G) \\right|$ 也被称作图 $G$ 的 阶 (Order) 。 形象地说，图是由若干点以及连接点与点的边构成的。","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"","slug":"图的存储方法","date":"2021-04-24T09:59:59.773Z","updated":"2021-03-27T07:53:11.640Z","comments":true,"path":"2021/04/24/图的存储方法/","link":"","permalink":"https://ender-003.github.io/2021/04/24/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"图的概念基本概念图 (Graph) 是一个二元组 $G=(V(G),E(G))$ 。其中 $V(G)$ 是非空集，称为 点集 (Vertex set) ，对于 VV 中的每个元素，我们称其为 顶点 (Vertex) 或 节点 (Node) ，简称 点 ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 边集 (Edge set) 。 常用 $G=(V,E)$ 表示图。 当 $V,E$ 都是有限集合时，称 $G$ 为 有限图 。 当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 无限图 。 图有多种，包括 无向图 (Undirected graph) ， 有向图 (Directed graph) ， 混合图 (Mixed graph) 等 若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 无向边 (Undirected edge) ，简称 边 (Edge) ，其中 $u, v \\in V$ 。设 $e = (u, v)$ ，则 $u$ 和 $v$ 称为 $e$ 的 端点 (Endpoint) 。 若 $G$ 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \\to v$ ，称作 有向边 (Directed edge) 或 弧 (Arc) ，在不引起混淆的情况下也可以称作 边 (Edge) 。设 $e = u \\to v$ ，则此时 $u$ 称为 $e$ 的 起点 (Tail) ， $v$ 称为 $e$ 的 终点 (Head) ，起点和终点也称为 $e$ 的 端点 (Endpoint) 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $u$ 的直接后继。","categories":[],"tags":[]},{"title":"How To Use Free V*N","slug":"How-To-Use-Free-VN","date":"2021-02-25T13:25:00.000Z","updated":"2021-04-02T05:21:50.446Z","comments":true,"path":"2021/02/25/How-To-Use-Free-VN/","link":"","permalink":"https://ender-003.github.io/2021/02/25/How-To-Use-Free-VN/","excerpt":"","text":"说在前面: 不是万不得已不要用梯子!还有, 本文方法只适用于Chrome浏览器或Edge(新版)浏览器, 没有的话可以去网上下载一个, 首推Chrome 以下为正文: 如何免费珂学上网首先上两个免费V*N的链接 Astar (有免费节点, 需注册(最近好像又不需要了), 较稳定, 推荐Canada节点) VeePN (有免费节点, 无需注册, 稳定性较上一个较差, 推荐Singapore节点) 然后你就会发现这个网站打不开, 这时就需要一个可以链接Google的小梯子了(作者已经准备好了) Link 提取码：a868 下载以后把文件夹放在一个专用的文件夹里然后去浏览器安装 这里安装过程以Chrome浏览器为例:点击： 右上角三个点 设置 左下角“扩展程序” 右上角“开发者模式” 左上“加载已解压的扩展程序” 选择刚下载下来的“谷歌访问助手”文件夹 然后等谷歌访问助手链接主服务器成功，点击上方那两个梯子的下载链接，再点击“添加至Chrome”，等下载完毕，自己选择节点就好啦","categories":[],"tags":[{"name":"颓废","slug":"颓废","permalink":"https://ender-003.github.io/tags/%E9%A2%93%E5%BA%9F/"}]},{"title":"分治笔记","slug":"分治笔记","date":"2020-12-19T09:00:00.000Z","updated":"2020-12-26T07:22:29.167Z","comments":true,"path":"2020/12/19/分治笔记/","link":"","permalink":"https://ender-003.github.io/2020/12/19/%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"分治1. 归并排序代码: 123456789101112131415161718192021222324252627282930#define N 10000010int num[N];int tmp[N]; //临时数组void merge(int l,int mid,int r)&#123; int i = l, j = mid + 1; int k = 0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; if(num[i]&lt;=num[j]) tmp[k++] = num[i++]; else tmp[k++] = num[j++]; &#125; while(i&lt;=mid) tmp[k++] = num[i++]; while(j&lt;=r) tmp[k++] = num[j++]; for (int f = 0; f &lt; k;f++) num[l + f] = tmp[f];&#125;//合并void merge_sort(int l,int r)&#123; if(l==r) return; int mid = (l + r) / 2; //中间数的位置 merge_sort(l, mid); merge_sort(mid + 1, r); //分治 merge(l, mid, r);&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"个人收录的颓废小游戏合集","slug":"个人收录颓废小游戏合集","date":"2020-12-05T09:12:00.000Z","updated":"2021-03-05T04:34:17.364Z","comments":true,"path":"2020/12/05/个人收录颓废小游戏合集/","link":"","permalink":"https://ender-003.github.io/2020/12/05/%E4%B8%AA%E4%BA%BA%E6%94%B6%E5%BD%95%E9%A2%93%E5%BA%9F%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%90%88%E9%9B%86/","excerpt":"","text":"某小游戏合集网站 MC Classic网页版(你没看错,就是网页版) 小霸王游戏(网页)合集 超级玛丽 贪吃蛇 尺规作图 “我”的二次元少女形象 你画我猜 大型像素枪战 小黑屋 多人联机坦克大作战(diep.io) 多人联机舰船大作战(和diep.io很像) 打飞字 slay.one 名字竞技场(很好玩!!!) 膜$ \\textbf{S}\\color{Red}iyuan$ 太空公司 多人联机跳跳大作战 贪吃陀螺 yorg.io(塔防) 猫国建设者 吃鸡 流浪日记(这个似乎挂了) 工匠 见缝插针","categories":[],"tags":[{"name":"颓废","slug":"颓废","permalink":"https://ender-003.github.io/tags/%E9%A2%93%E5%BA%9F/"}]},{"title":"搜索笔记","slug":"搜索笔记","date":"2020-11-28T06:12:00.000Z","updated":"2020-12-20T12:33:36.811Z","comments":true,"path":"2020/11/28/搜索笔记/","link":"","permalink":"https://ender-003.github.io/2020/11/28/%E6%90%9C%E7%B4%A2%E7%AC%94%E8%AE%B0/","excerpt":"","text":"搜索 搜索，也就是对状态空间进行枚举。通过穷尽所有的可能，来找到最优解，或者统计合法解的个数。 搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。 搜索是一些高级算法的基础，在 OI 中，纯粹的搜索往往也是得到 部分分 的强有力的手段，但可以通过纯粹的搜索拿到满分的题目非常少的。 搜索的策略：深度、广度 重要的概念： 状态空间：所有合理状态的集合 搜索树：从初始状态出发能访问的所有状态节点及对应路径构成的一棵树 状态：各种属性（位置、步数、和、路径记录[有时可以用全局变量记录]） 初始状态：状态的各种属性为初始值 目标状态：一般是状态的某个属性满足一定条件下的状态，比如达到指定位置、和达到一定值 可行解：所有目标状态都是可行解 最优解：目标状态中满足最优性（某属性最小、最大） 解集：有时要求输出一个最优状态、有时要求输出所有的目标状态，有时要求输出任意一个目标状态 搜索的步骤： 深搜：从上往下，到底回溯，每次向下搜索都将之前一步的状态保存下来（入栈），特别地，如果用函数递归实现，除全局变量外，不需要手动去保存状态。 广搜：按层遍历，适用最优，队列中按层保存着每一层的状态。 搜索的优化： 剪枝 回溯 记忆化 代码框架：DFS123456789101112131415161718192021全局状态变量void dfs(当前状态)&#123; if(当前状态是目标状态) // 判断 进行相应处理（计数、输出当前解、更新最优解、退出返回等） // 扩展 for(所有可行的新状态)&#123; if(新状态没有访问过 &amp;&amp; 需要访问)&#123; // 可行性剪枝、最优性剪枝、重复性剪枝 标记 dfs(新状态) 取消标记 //回溯 &#125; &#125;&#125;int main()&#123; ... dfs(初始状态); ...&#125; BFS12345678910111213141516全局状态变量定义状态队列void BFS()&#123; 初始状态入队 while(队列不为空)&#123; 取出队首状态作为当前状态 if(当前状态是目标状态) 进行相应处理（输出当前解、更新最优解、退出返回等） else for(所有可行的新状态)&#123; if(新状态没有访问过 &amp;&amp; 需要访问)&#123; // 可行性剪枝、最优性剪枝、重复性剪枝 新状态入队 &#125; &#125;&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"课堂笔记整合","slug":"课堂笔记整合","date":"2020-11-28T06:12:00.000Z","updated":"2020-12-20T12:23:03.431Z","comments":true,"path":"2020/11/28/课堂笔记整合/","link":"","permalink":"https://ender-003.github.io/2020/11/28/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88/","excerpt":"","text":"搜索 分治","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-05T05:33:00.000Z","updated":"2020-10-07T08:00:27.181Z","comments":true,"path":"2020/10/05/hello-world/","link":"","permalink":"https://ender-003.github.io/2020/10/05/hello-world/","excerpt":"","text":"Hello World这是我的第一篇文章 以此纪念Blog正式建成","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"https://ender-003.github.io/tags/Hello-World/"}]}],"categories":[],"tags":[{"name":"合集","slug":"合集","permalink":"https://ender-003.github.io/tags/%E5%90%88%E9%9B%86/"},{"name":"OI","slug":"OI","permalink":"https://ender-003.github.io/tags/OI/"},{"name":"颓废","slug":"颓废","permalink":"https://ender-003.github.io/tags/%E9%A2%93%E5%BA%9F/"},{"name":"Hello World","slug":"Hello-World","permalink":"https://ender-003.github.io/tags/Hello-World/"}]}