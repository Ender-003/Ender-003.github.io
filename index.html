<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Ender_&#39;s Blog</title>
  <meta name="author" content="Ender" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="Ender_&#39;s Blog" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="Ender_&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Ender_&#39;s Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-05-22T08:27:00.000Z"><a href="/2021/05/22/LaTeX,KaTeX/">2021-05-22</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/22/LaTeX,KaTeX/">LaTeX/KaTeX语法集合 --- By 离散小波变换°</a></h1>
  

    </header>
    <div class="entry">
      
        <p>包含内容：语法/技巧/注意事项。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan">https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/IowaBattleship/latex-ru-men">https://www.luogu.com.cn/blog/IowaBattleship/latex-ru-men</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/luogu/how-to-use-markdown">https://www.luogu.com.cn/blog/luogu/how-to-use-markdown</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/93465/markdown-yu-latex-chang-yong-yu-fa-zheng-li">https://www.luogu.com.cn/blog/93465/markdown-yu-latex-chang-yong-yu-fa-zheng-li</a></li>
<li><a target="_blank" rel="noopener" href="https://katex.org/docs/supported.html#math-operators">https://katex.org/docs/supported.html#math-operators</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/McHf/katex-gong-shi-tai-quan">https://www.luogu.com.cn/blog/McHf/katex-gong-shi-tai-quan</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/hs3jg81l">https://www.luogu.com.cn/paste/hs3jg81l</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/wmm62fg7">https://www.luogu.com.cn/paste/wmm62fg7</a></li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/合集/">合集</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-05-22T06:23:00.000Z"><a href="/2021/05/22/最小生成树/">2021-05-22</a></time>
      
      
  
    <h1 class="title"><a href="/2021/05/22/最小生成树/">最小生成树</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>通过前面的学习，对于含有 n 个顶点的连通图来说可能包含有多种生成树，例如图 1 所示：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F911161130950.png" alt="img"></p>
<center>图 1 连通图的生成树</center>

<p>图 1 中的连通图和它相对应的生成树，可以用于解决实际生活中的问题：假设A、B、C 和 D 为 4 座城市，为了方便生产生活，要为这 4 座城市建立通信。对于 4 个城市来讲，本着节约经费的原则，只需要建立 3 个通信线路即可，就如图 1（b）中的任意一种方式。</p>
<p>在具体选择采用（b）中哪一种方式时，需要综合考虑城市之间间隔的距离，建设通信线路的难度等各种因素，将这些因素综合起来用一个数值表示，当作这条线路的权值。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170911/2-1F911161350260.png" alt=""></p>
<center>图 2 无向网</center>

<p>假设通过综合分析，城市之间的权值如 $图2(a)$ 所示，对于 $(b)$ 的方案中，选择权值总和为 7 的两种方案最节约经费。</p>
<p>这就是本节要讨论的最小生成树的问题，简单得理解就是给定一个带有权值的连通图（连通网），如何从众多的生成树中筛选出权值总和最小的生成树，即为该图的最小生成树。</p>
<p>给定一个连通网，求最小生成树的方法有： $Prim$ 算法和 $Kruskal$ 算法。</p>
<h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><blockquote>
<p>一种贪心的算法，适用于稠密图，时间复杂度 $O(n^2)$ 。</p>
<p>核心思想：每次挑一条与当前集合相连的最短边。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>普里姆算法在找最小生成树时，将顶点分为两类，一类是在查找的过程中已经包含在树中的（假设为 A 类），剩下的是另一类（假设为 B 类），并且 $Prim$ 算法总是维护最小生成树的一部分，类似 $Dijkstra$ 算法。</p>
<p>对于给定的连通网，起始状态全部顶点都归为 B 类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A 类；然后找出 B 类中到 A 类中的顶点之间权值最小的顶点，将之从 B 类移至 A 类，如此重复，直到 B 类中没有顶点为止。所走过的顶点和边就是该连通图的最小生成树。</p>
<h2 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h2><blockquote>
<p>❓为什么每次选最小边是正确的呢</p>
</blockquote>
<p>Prim 算法是基于切分定理的。</p>
<ul>
<li>切分（Cut）：把图中的节点分为两部分，称为一个切分。下图有个切分 $C = (S, T)，S = {A, B, D}，T = {C, E}$</li>
</ul>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/64616_db57f71568-1.png" alt="img"></p>
<ul>
<li>横切边（ $Crossing Edge$ ）：如果一个边的两个顶点，分别属于切分的两部分，这个边称为横切边。比如上图的边 BC、BE、DE 就是横切边。</li>
<li>切分定理：给定任意切分，横切边中权值最小的边必然属于最小生成树。<ul>
<li>证明：假设原图切分后的两个部分各自组成了一棵最小生成子树，那么在这两个部分之间加入任意一条边都可以将形成整个图的生成树。很容易得知，加入所有横切边中权值最小的边就可以形成最小生成树。</li>
</ul>
</li>
</ul>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><p>例如，通过普里姆算法查找图 2（a）的最小生成树的步骤为：</p>
<p>假如从顶点A出发，顶点 B、C、D 到顶点 A 的权值分别为 2、4、2，所以，对于顶点 A 来说，顶点 B 和顶点 D 到 A 的权值最小，假设先找到的顶点 B：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170911/2-1F911161I4302.png" alt="img"></p>
<p>继续分析顶点 C 和 D，顶点 C 到 B 的权值为 3，到 A 的权值为 4；顶点 D 到 A 的权值为 2，到 B 的权值为无穷大（如果之间没有直接通路，设定权值为无穷大）。所以顶点 D 到 A 的权值最小：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/170911/2-1F911161S35D.png" alt="img"></p>
<p>最后，只剩下顶点 C，到 A 的权值为 4，到 B 的权值和到 D 的权值一样大，为 3。所以该连通图有两个最小生成树：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F911161910B7.png" alt="img"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>具体实现代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">S:当前已经在联通块中的所有点的集合</span><br><span class="hljs-comment">1. dist[i] = inf</span><br><span class="hljs-comment">2. for n 次</span><br><span class="hljs-comment">    t&lt;-S外离S最近的点</span><br><span class="hljs-comment">    利用t更新S外点到S的距离</span><br><span class="hljs-comment">    st[t] = true</span><br><span class="hljs-comment">n次迭代之后所有点都已加入到S中</span><br><span class="hljs-comment">联系：Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> g[N][N], dist[N];<br><span class="hljs-comment">//邻接矩阵存储所有边</span><br><span class="hljs-comment">//dist存储其他点到S的距离</span><br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//如果图不连通返回INF, 否则返回res</span><br>    <span class="hljs-built_in">memset</span>(dist, INF, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">//总权值</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) <br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        <span class="hljs-comment">//寻找离集合S最近的点        </span><br>        <span class="hljs-keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-comment">//判断是否连通，有无最小生成树</span><br><br>        <span class="hljs-keyword">if</span>(i) res += dist[t];<br>        <span class="hljs-comment">//cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; res &lt;&lt; endl;</span><br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//更新最新S的权值和</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">int</span> u, v, w;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(i ==j) g[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> g[i][j] = INF;<br><br>    <span class="hljs-keyword">while</span>(m--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        g[u][v] = g[v][u] = min(g[u][v], w);<br>    &#125;<br>    <span class="hljs-keyword">int</span> t = prim();<br>    <span class="hljs-keyword">if</span>(t == INF) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>普里姆算法的运行效率只与连通网中包含的顶点数相关，而和网所含的边数无关。所以普里姆算法适合于解决边稠密的网，该算法运行的时间复杂度为：O(n^2)<em>O</em>(<em>n</em>2)。</p>
<blockquote>
<p>如果连通网中所含边的绸密度不高，则建议使用克鲁斯卡尔算法求最小生成树。</p>
</blockquote>
<h1 id="堆优化的Prim算法"><a href="#堆优化的Prim算法" class="headerlink" title="堆优化的Prim算法"></a>堆优化的Prim算法</h1><blockquote>
<p>堆 $prime$ 的优化，主要从for循环里的两个for循环下手：</p>
<p>第一个for循环是找最小值，方式使用堆进行优化；</p>
<p>对第二个for循环，用邻接表进行操作。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果使用二叉堆，prim算法的复杂度能降到O(E log V)。</p>
<p>之前实现的这个Prim算法，是用邻接矩阵表示图。而堆优化的Prim算法，将用邻接表来表示图，且使用最小堆来寻找，连接MST集合和非MST集合的边中，最小权值的那条边。</p>
<p>基本思想：基本思想和原Prim算法大体相同，但此算法是，根据邻接表，通过广度优先遍历（BFS）来遍历所有节点，遍历的总操作为O(V+E)次数。同时使用最小堆存储非MST集合中的节点，每次遍历时用最小堆来选择节点。最小堆操作的时间复杂度为O(LogV)。</p>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>创建一个大小为V的最小堆，V是图的节点个数。最小堆的每个元素，存储的是节点id和节点的key值。</li>
<li>初始化时，让堆的第一个元素作为最小生成树的根节点，赋值根节点的key值为0。其余节点的key值赋值为无穷大。 3.只要最小堆不为空，就重复以下步骤： (i)从最小堆中，抽取最小key值的节点，作为u。 (ii)对于u的每个邻接点v，检查v是否在最小堆中（即还没有加入到MST中）。如果v在最小堆中，且v的key值是大于边u-v的权值时，就更新v的key值为边u-v的权值。</li>
</ol>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">510</span>, MAXM = <span class="hljs-number">2</span> * <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><span class="hljs-keyword">int</span> h[MAXM], e[MAXM], w[MAXM], ne[MAXM], idx;<br><span class="hljs-keyword">bool</span> vis[MAXN];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> vis);<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; q;<br>    q.push(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (!q.empty())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.top();<br>        q.pop();<br>        <span class="hljs-keyword">int</span> ver = t.second, dst = t.first;<br>        <span class="hljs-keyword">if</span> (vis[ver]) <span class="hljs-keyword">continue</span>;<br>        vis[ver] = <span class="hljs-literal">true</span>, sum += dst, ++cnt;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (!vis[j]) &#123;<br>                q.push(&#123;w[i], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt != n) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a, b, w;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; w;<br>        add(a, b, w);<br>        add(b, a, w);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> t = Prim();<br>    <span class="hljs-keyword">if</span> (t == INF) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-built_in">endl</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>使用二叉堆，prim算法的复杂度降到了 $O(E log V)$ 。</p>
<h1 id="克鲁斯卡尔算法-Kruskal算法"><a href="#克鲁斯卡尔算法-Kruskal算法" class="headerlink" title="克鲁斯卡尔算法(Kruskal算法)"></a>克鲁斯卡尔算法(Kruskal算法)</h1><blockquote>
<p>适用于稀疏图，时间复杂度 O(mlogm)<em>O</em>(<em>m<strong>l</strong>o<strong>g</strong>m</em>)。</p>
<p>核心思想：从小到大挑不多余的边。</p>
</blockquote>
<p>之前介绍了求最小生成树之普里姆算法。该算法从顶点的角度为出发点，时间复杂度为O(n^2)<em>O</em>(<em>n</em>2)，更适合与解决边的绸密度更高的连通网。</p>
<p>本节所介绍的克鲁斯卡尔算法，从边的角度求网的最小生成树，时间复杂度为O(E\log E)<em>O</em>(<em>E</em>log<em>E</em>)。和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树。</p>
<p>对于任意一个连通网的最小生成树来说，在要求总的权值最小的情况下，最直接的想法就是将连通网中的所有边按照权值大小进行升序排序，从小到大依次选择。</p>
<p>由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点：</p>
<ul>
<li>生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路；</li>
<li>对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点。</li>
</ul>
<blockquote>
<p>连接 n 个顶点在不产生回路的情况下，只需要 n-1 条边。</p>
</blockquote>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>所以克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。</p>
<blockquote>
<p>判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。</p>
</blockquote>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>假设遍历到一条由顶点 A 和 B 构成的边，而顶点 A 和顶点 B 标记不同，此时不仅需要将顶点 A 的标记更新为顶点 B 的标记，还需要更改所有和顶点 A 标记相同的顶点的标记，全部改为顶点 B 的标记。</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F911163R01W.png" alt="img"></p>
<center>图 1 连通网</center>

<p>例如，使用克鲁斯卡尔算法找图 1 的最小生成树的过程为：</p>
<p>首先，在初始状态下，对各顶点赋予不同的标记（用颜色区别），如下图所示：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F91116422K37.png" alt="img"></p>
<center>（1）</center>

<p>对所有边按照权值的大小进行排序，按照从小到大的顺序进行判断，首先是（1，3），由于顶点 1 和顶点 3 标记不同，所以可以构成生成树的一部分，遍历所有顶点，将与顶点 3 标记相同的全部更改为顶点 1 的标记，如（2）所示：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F911163922M6.png" alt="img"></p>
<center>（2）</center>

<p>其次是（4，6）边，两顶点标记不同，所以可以构成生成树的一部分，更新所有顶点的标记为：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F91116431A11.png" alt="img"></p>
<center>（3）</center>

<p>其次是（2，5）边，两顶点标记不同，可以构成生成树的一部分，更新所有顶点的标记为：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F911164335108.png" alt="img"></p>
<center>（4）</center>

<p>然后最小的是（3，6）边，两者标记不同，可以连接，遍历所有顶点，将与顶点 6 标记相同的所有顶点的标记更改为顶点 1 的标记：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F91116435D40.png" alt="img"></p>
<center>（5）</center>

<p>继续选择权值最小的边，此时会发现，权值为 5 的边有 3 个，其中（1，4）和（3，4）各自两顶点的标记一样，如果连接会产生回路，所以舍去，而（2，3）标记不一样，可以选择，将所有与顶点 2 标记相同的顶点的标记全部改为同顶点 3 相同的标记：</p>
<p><img src="https://gitee.com/limorton/typora-picgo/raw/master-picture/pic2021/2-1F91116442R29.png" alt="img"></p>
<center>（6）</center>

<p>当选取的边的数量相比与顶点的数量小 1 时，说明最小生成树已经生成。所以最终采用克鲁斯卡尔算法得到的最小生成树为（6）所示。</p>
<h2 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">4e5</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> p[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b, w;<br><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge &amp;e) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> w &lt; e.w;<br>    &#125;<br>&#125; es[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = find(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br><br>    sort(es, es + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a = es[i].a, b = es[i].b, w = es[i].w;<br>        a = find(a), b = find(b);<br>        <span class="hljs-keyword">if</span> (a != b) &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        es[i] = &#123;a, b, w&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> t = kruskal();<br>    <span class="hljs-keyword">if</span> (t == INF) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; t;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a href="javascript:;">Copy</a></p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>排序：O(E\log E)<em>O</em>(<em>E</em>log<em>E</em>)，采用并查集选边合并：O(E\alpha (V))<em>O</em>(<em>E**α</em>(<em>V</em>))，总时间复杂度：O(E\log E)<em>O</em>(<em>E</em>log<em>E</em>)</p>
<h1 id="对比两种最小生成树算法"><a href="#对比两种最小生成树算法" class="headerlink" title="对比两种最小生成树算法"></a>对比两种最小生成树算法</h1><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 1. 把图中的所有边按代价从小到大排序； 2. 把图中的n个顶点看成独立的n棵树组成的森林； 3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</p>
<h2 id="Prim算法-1"><a href="#Prim算法-1" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p>
<ol>
<li>图的所有顶点集合为V；初始令集合u={s},v=V−u;</li>
<li>在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。</li>
<li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li>
</ol>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-04-24T09:59:59.778Z"><a href="/2021/04/24/图笔记- Ⅱ/">2021-04-24</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/24/图笔记- Ⅱ/">图笔记 Ⅱ(存储&amp;便利)</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="1-直接存边"><a href="#1-直接存边" class="headerlink" title="1. 直接存边"></a>1. 直接存边</h2><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权）</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-keyword">int</span> u, v, w;   <span class="hljs-comment">// 一条边的 起点、终点、权值</span><br>&#125;;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-built_in">vector</span>&lt;Edge&gt; e;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; vis;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (e[i].u == u &amp;&amp; e[i].v == v) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (e[i].u == u) &#123;<br>            dfs(e[i].v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>  vis.resize(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  e.resize(m + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) <span class="hljs-built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>查询是否存在某条边： $O(m)$ 。</p>
<p>遍历一个点的所有出边： $O(m)$ 。</p>
<p>遍历整张图： $O(nm)$ 。</p>
<p>空间复杂度： $O(m)$ 。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>由于直接存边的遍历效率低下，一般不用于遍历图。</p>
<p>在 $Kruskal$ 算法中，由于需要将边按边权排序，需要直接存边。</p>
<p>在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。</p>
<h2 id="2-邻接矩阵"><a href="#2-邻接矩阵" class="headerlink" title="2. 邻接矩阵"></a>2. 邻接矩阵</h2><p>使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在 u<em>u</em> 到 v<em>v</em> 的边，为 0 表示不存在。</p>
<p>如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 u<em>u</em> 到 v<em>v</em> 的边的边权，0 表示没有连接，其他值表示权重。</p>
<p>如果是无向图，则将一条无向边拆成两条方向相反的边即可。（所谓的「无向」，也就等同于「双向」）</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-keyword">bool</span> adj[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-keyword">return</span> adj[u][v]; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;<br>        <span class="hljs-keyword">if</span> (adj[u][v]) &#123;<br>            dfs(v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    fill_n(vis, N, <span class="hljs-literal">false</span>);<br>    fill_n(adj, N*N, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        adj[u][v] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// u-&gt;v 有条单向边</span><br>        <span class="hljs-comment">// 如果是双向边</span><br>        <span class="hljs-comment">// adj[u][v] = adj[v][u] = true;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>查询是否存在某条边： $O(1)$ 。</p>
<p>遍历一个点的所有出边： $O(n)$ 。</p>
<p>遍历整张图： $O(n^2)$ 。</p>
<p>空间复杂度： $O(n^2)$ 。</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>邻接矩阵只适用于没有重边（或重边可以忽略）的情况。</p>
<p>其最显著的优点是可以 $O(1)$ 查询一条边是否存在。</p>
<p>由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会 <strong>在稠密图上使用邻接矩阵</strong>。并且，在稠密图上使用邻接矩阵的运行效率远高于邻接表，这是因为 CPU 中顺序访问的速度是远高于随机访问的（缓存命中）。</p>
<p><img src="%E5%9B%BE%E7%AC%94%E8%AE%B0.assets/%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg" alt=""></p>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">bool</span> vis[N];     <span class="hljs-comment">// 标记是否访问过</span><br><span class="hljs-keyword">bool</span> adj[N][N];  <span class="hljs-comment">// 邻接矩阵存图</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;<br>        <span class="hljs-keyword">if</span> (adj[u][v] &amp;&amp; !vis[u]) &#123;   <span class="hljs-comment">// 有边，并且没访问过，访问</span><br>            dfs(v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    fill_n(vis, N, <span class="hljs-literal">false</span>);<br>    fill_n(adj, N*N, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        adj[u][v] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// u-&gt;v 有条单向边</span><br>        <span class="hljs-comment">// 如果是双向边</span><br>        <span class="hljs-comment">// adj[u][v] = adj[v][u] = true;</span><br>    &#125;<br>    dfs(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">bool</span> vis[N];     <span class="hljs-comment">// 标记是否访问过</span><br><span class="hljs-keyword">bool</span> adj[N][N];  <span class="hljs-comment">// 邻接矩阵存图</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(s);<br>    <span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> k = q.front(); q.pop();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (adj[k][i] &amp;&amp; !vis[i])   <span class="hljs-comment">// 有边，并且没访问过，访问</span><br>            q.push(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol>
<li>时间复杂度是 $O(n^3)$ ，因此，只适用于 $n &lt; 500$ 的这种结点数不多的情况。</li>
<li>它是多源最短路的，可以求出任何两点之间的最短路。</li>
<li>支持负边权</li>
<li>能够判断图中是否存在负回路</li>
</ol>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dis[N][N];   <span class="hljs-comment">// dis[i][j]: i-&gt;j 最短距离 </span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">证明：定义 dis[i][j][k] 表示从 i 到 j 的可以经过 1~k 号结点的最短路径，此问题可以被分解为两个子问题</span><br><span class="hljs-comment">（1）不经过 k 号结点，即  dis[i][j][k-1]</span><br><span class="hljs-comment">（2）经过 k 号结点，即 dis[i][k][k-1]+dis[k][j][k-1];</span><br><span class="hljs-comment">因此，有：</span><br><span class="hljs-comment">dis[i][j][k] = min(dis[i][j][k-1], dis[i][k][k-1], dis[k][j][k-1]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">上式中第三维 k 可以省略，则有： </span><br><span class="hljs-comment">dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">虽然 i,j,k 的顺序不保证，导致上式中 dis[i][k] 和 dis[k][j] 可能是已经被更新过的 dis[i][k][k] 和 dis[k][j][k] 了，</span><br><span class="hljs-comment">但是这并不影响其正确性。因为更新后的值一定会变得更小，不会影响最终结果。 </span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; g[i][j];<br>            dis[i][j] = g[i][j];<br>        &#125;<br>    <span class="hljs-comment">// floyd 求任意两点间的最短路径 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)   <span class="hljs-comment">// 枚举中间点 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n;j++)<br>                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);<br>                <br>    <span class="hljs-comment">// 判断负环 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[i][i] &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;存在负环&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;       <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><p>只适用于正权边</p>
<p>思想是贪心的思想</p>
<p>朴素版 $Dijkstra$ 适合稠密图</p>
<h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>集合S为已经确定最短路径的点集。</p>
<ol>
<li>初始化距离： $1$ 号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。</li>
<li>循环 $n$ 次，每一次将集合 $S$ 之外距离最短 $X$ 的点加入到 $S$ 中去（这里的距离最短指的是距离 $1$ 号点最近。点 $X$ 的路径一定最短，基于贪心，严格证明待看）。然后用点 $X$ 更新 $X$ 邻接点的距离。</li>
</ol>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>寻找路径最短的点：$O(n^2)$</p>
<p>加入集合 $S$：$O(n)$</p>
<p>更新距离：$O(m)$</p>
<p>所以总的时间复杂度为 $O(n^2)$</p>
<h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-comment">//邻接矩阵</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct node&#123;</span><br><span class="hljs-comment">	int id, w;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">vector&lt;node&gt; g[N];</span><br><span class="hljs-comment">//邻接表</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> visited[N];   <span class="hljs-comment">// 依据访问过与否将所有节点分成两个部分(集合)</span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 确定集合中距离初始节点最近的点 t</span><br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        visited[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 加入 S 集合</span><br>        <span class="hljs-comment">// 从 t 出发，更新相邻点的 dist</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            dist[j] = min(dist[j], dist[t] + g[t][j]);<br>        	<span class="hljs-comment">//dist[j] = min(dist[j], dist[t] + g[t][j].w);</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(g));<br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        g[x][y] = min(g[x][y], c);   <span class="hljs-comment">// 因为有重边，所以只保留最短边</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆优化-Dijkstra"><a href="#堆优化-Dijkstra" class="headerlink" title="堆优化 Dijkstra"></a>堆优化 Dijkstra</h3><blockquote>
<p>任何场景均适合</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>堆优化版的 $Dijkstra$ 是对朴素版 $Dijkstra$ 进行了优化，在朴素版 $Dijkstra$ 中时间复杂度最高的寻找距离最短的点 $O(n^2)$ 可以使用最小堆优化。</p>
<ol>
<li>1 号点的距离初始化为零，其他点初始化成无穷大。</li>
<li>将一号点放入堆中。</li>
<li>不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版 $dijkstra$ 找到 $S$ 外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。</li>
</ol>
<h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>寻找路径最短的点：$O(n)$</p>
<p>加入集合S：$O(n)$</p>
<p>更新距离：$O(mlog_n)$</p>
<p>所以总的时间复杂度为 $O(m{log}_n)$</p>
<h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">150010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> y, w;<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;node&gt; g[N];<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">// 如果为true说明这个点的最短路径已经确定</span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    g[x].push_back((node)&#123;y, c&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; q; <span class="hljs-comment">// 定义一个小根堆</span><br>    <span class="hljs-comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    </span><br>    <span class="hljs-comment">// 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span><br>    q.push(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span><br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        PII tmp = q.top(); <span class="hljs-comment">// 取不在集合S中距离最短的点</span><br>        q.pop();<br>        <span class="hljs-keyword">int</span> cur = tmp.second, d = tmp.first;<br><br>        <span class="hljs-keyword">if</span>(st[cur]) <span class="hljs-keyword">continue</span>;<br>        st[cur] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加入集合 S 中</span><br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> id = g[cur][i].y, w = g[cur][i].w;<br>            <span class="hljs-keyword">if</span>(dist[id] &gt; d + w)<br>            &#123;<br>                dist[id] = d + w;<br>                q.push(&#123; dist[id], id &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        add(x, y, c);<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="链式前向星写法"><a href="#链式前向星写法" class="headerlink" title="链式前向星写法"></a>链式前向星写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">150010</span>;<br><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-keyword">int</span> w[N]; <span class="hljs-comment">// 用来存权重</span><br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">// 如果为true说明这个点的最短路径已经确定</span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-comment">// 稀疏图用链式前向星来存</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    w[idx] = c; <span class="hljs-comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span><br>    e[idx] = y; <span class="hljs-comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span><br>    ne[idx] = h[x]; <span class="hljs-comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span><br>    h[x] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dist));<br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; q; <span class="hljs-comment">// 定义一个小根堆</span><br>    <span class="hljs-comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    </span><br>    <span class="hljs-comment">// 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span><br>    q.push(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span><br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        PII k = q.top(); <span class="hljs-comment">// 取不在集合S中距离最短的点</span><br>        q.pop();<br>        <span class="hljs-keyword">int</span> ver = k.second, distance = k.first;<br><br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加入集合 S 中</span><br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i]; <span class="hljs-comment">// i只是个下标，e中在存的是i这个下标对应的点。</span><br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                q.push(&#123; dist[j], j &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        add(x, y, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-04-24T09:59:59.776Z"><a href="/2021/04/24/图笔记-Ⅰ(性质)/">2021-04-24</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/24/图笔记-Ⅰ(性质)/">图笔记 Ⅰ(性质)</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>图 (Graph)</strong> 是一个二元组 $G=(V(G), E(G))$ 。其中 $V(G)$ 是非空集，称为 <strong>点集 (Vertex set)</strong> ，对于 $V$ 中的每个元素，我们称其为 <strong>顶点 (Vertex)</strong> 或 <strong>节点 (Node)</strong> ，简称 <strong>点</strong> ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 <strong>边集 (Edge set)</strong> 。</p>
<p>常用 $G=(V,E)$ 表示图。</p>
<p>当 $V,E$ 都是有限集合时，称 $G$ 为 <strong>有限图</strong> 。</p>
<p>当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 <strong>无限图</strong> 。</p>
<p>图有多种，包括 <strong>无向图 (Undirected graph)</strong> ， <strong>有向图 (Directed graph)</strong> ， <strong>混合图 (Mixed graph)</strong> 等</p>
<p>若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 <strong>无向边 (Undirected edge)</strong> ，简称 <strong>边 (Edge)</strong> ，其中 $u, v \in V$ 。设 $e = (u, v)$，则 $u$ 和 $v$ 称为 $e$ 的 <strong>端点 (Endpoint)</strong> 。</p>
<p>若 $G 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \to v$ ，称作 <strong>有向边 (Directed edge)</strong> 或 <strong>弧 (Arc)</strong> ，在不引起混淆的情况下也可以称作 <strong>边 (Edge)</strong> 。设 $e = u \to v$ ，则此时 $u$ 称为 $e$ 的 <strong>起点 (Tail)</strong> ， $v$ 称为 $e$ 的 <strong>终点 (Head)</strong> ，起点和终点也称为 $e$ 的 <strong>端点 (Endpoint)</strong> 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $u$ 的直接后继。</p>
<p>若 $G$ 为混合图，则 $E$ 中既有向边，又有无向边。</p>
<p>若 $G$ 的每条边 $e_k = (u_k,v_k)$ 都被赋予一个数作为该边的 <strong>权</strong> ，则称 $G$ 为 <strong>赋权图</strong> 。如果这些权都是正实数，就称 $G$ 为 <strong>正权图</strong> 。</p>
<p>图 $G$ 的点数 $\left| V(G) \right|$ 也被称作图 $G$ 的 <strong>阶 (Order)</strong> 。</p>
<p><strong>形象地说，图是由若干点以及连接点与点的边构成的。</strong></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-04-24T09:59:59.773Z"><a href="/2021/04/24/图的存储方法/">2021-04-24</a></time>
      
      
  
    <h1 class="title"><a href="/2021/04/24/图的存储方法/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>图 (Graph)</strong> 是一个二元组 $G=(V(G),E(G))$ 。其中 $V(G)$ 是非空集，称为 <strong>点集 (Vertex set)</strong> ，对于 V<em>V</em> 中的每个元素，我们称其为 <strong>顶点 (Vertex)</strong> 或 <strong>节点 (Node)</strong> ，简称 <strong>点</strong> ； $E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 <strong>边集 (Edge set)</strong> 。</p>
<p>常用 $G=(V,E)$ 表示图。</p>
<p>当 $V,E$ 都是有限集合时，称 $G$ 为 <strong>有限图</strong> 。</p>
<p>当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 <strong>无限图</strong> 。</p>
<p>图有多种，包括 <strong>无向图 (Undirected graph)</strong> ， <strong>有向图 (Directed graph)</strong> ， <strong>混合图 (Mixed graph)</strong> 等</p>
<p>若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$ ，称作 <strong>无向边 (Undirected edge)</strong> ，简称 <strong>边 (Edge)</strong> ，其中 $u, v \in V$ 。设 $e = (u, v)$ ，则 $u$ 和 $v$ 称为 $e$ 的 <strong>端点 (Endpoint)</strong> 。</p>
<p>若 $G$ 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$ ，有时也写作 $u \to v$ ，称作 <strong>有向边 (Directed edge)</strong> 或 <strong>弧 (Arc)</strong> ，在不引起混淆的情况下也可以称作 <strong>边 (Edge)</strong> 。设 $e = u \to v$ ，则此时 $u$ 称为 $e$ 的 <strong>起点 (Tail)</strong> ， $v$ 称为 $e$ 的 <strong>终点 (Head)</strong> ，起点和终点也称为 $e$ 的 <strong>端点 (Endpoint)</strong> 。并称 $u$ 是 $v$ 的直接前驱， $v$ 是 $u$ 的直接后继。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-02-25T13:25:00.000Z"><a href="/2021/02/25/How-To-Use-Free-VN/">2021-02-25</a></time>
      
      
  
    <h1 class="title"><a href="/2021/02/25/How-To-Use-Free-VN/">How To Use Free V*N</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="说在前面-不是万不得已不要用梯子"><a href="#说在前面-不是万不得已不要用梯子" class="headerlink" title="说在前面: 不是万不得已不要用梯子!"></a>说在前面: 不是万不得已不要用梯子!</h4><p><strong><font color='FFF00'>还有, 本文方法只适用于Chrome浏览器或Edge(新版)浏览器, 没有的话可以去网上下载一个, 首推Chrome</font></strong></p>
<p><strong>以下为正文: </strong></p>
<h1 id="如何免费珂学上网"><a href="#如何免费珂学上网" class="headerlink" title="如何免费珂学上网"></a>如何免费珂学上网</h1><h3 id="首先上两个免费V-N的链接"><a href="#首先上两个免费V-N的链接" class="headerlink" title="首先上两个免费V*N的链接"></a>首先上两个免费V*N的链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/astar-vpn-free-and-fast-v/jajilbjjinjmgcibalaakngmkilboobh?hl=zh-CN"><font color="#00F">Astar</font></a><font color="#FF0000"> (有免费节点, 需注册(最近好像又不需要了), 较稳定, 推荐Canada节点)</font></li>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/veepn-unlimited-free-fast/majdfhpaihoncoakbjgbdhglocklcgno"><font color="#00F">VeePN</font></a><font color="#FF0000"> (有免费节点, 无需注册, 稳定性较上一个较差, 推荐Singapore节点)</font></li>
</ul>
<hr>
<p>然后你就会发现这个网站打不开, 这时就需要一个可以链接Google的小梯子了(作者已经准备好了)</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/15Ra66qMpPJWX63r7k5rIaA"><font color='#00F'>Link</font></a></p>
<p><strong>提取码：a868</strong></p>
<p>下载以后把文件夹放在一个专用的文件夹里然后去浏览器安装</p>
<h3 id="这里安装过程以Chrome浏览器为例"><a href="#这里安装过程以Chrome浏览器为例" class="headerlink" title="这里安装过程以Chrome浏览器为例:"></a>这里安装过程以Chrome浏览器为例:</h3><p>点击：</p>
<ol>
<li>右上角三个点</li>
<li>设置</li>
<li>左下角“扩展程序”</li>
<li>右上角“开发者模式”</li>
<li>左上“加载已解压的扩展程序”</li>
<li>选择刚下载下来的“谷歌访问助手”文件夹</li>
</ol>
<h3 id="然后等谷歌访问助手链接主服务器成功，点击上方那两个梯子的下载链接，再点击“添加至Chrome”，等下载完毕，自己选择节点就好啦"><a href="#然后等谷歌访问助手链接主服务器成功，点击上方那两个梯子的下载链接，再点击“添加至Chrome”，等下载完毕，自己选择节点就好啦" class="headerlink" title="然后等谷歌访问助手链接主服务器成功，点击上方那两个梯子的下载链接，再点击“添加至Chrome”，等下载完毕，自己选择节点就好啦"></a>然后等谷歌访问助手链接主服务器成功，点击上方那两个梯子的下载链接，再点击“添加至Chrome”，等下载完毕，自己选择节点就好啦</h3>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/颓废/">颓废</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-12-19T09:00:00.000Z"><a href="/2020/12/19/分治笔记/">2020-12-19</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/19/分治笔记/">分治笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h3><p>代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10000010</span><br><span class="hljs-keyword">int</span> num[N];<br><span class="hljs-keyword">int</span> tmp[N];		<span class="hljs-comment">//临时数组</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(num[i]&lt;=num[j])<br>            tmp[k++] = num[i++];<br>        <span class="hljs-keyword">else</span><br>            tmp[k++] = num[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)<br>        tmp[k++] = num[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)<br>        tmp[k++] = num[j++];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f = <span class="hljs-number">0</span>; f &lt; k;f++)<br>        num[l + f] = tmp[f];<br>&#125;<br><span class="hljs-comment">//合并</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//中间数的位置</span><br>    merge_sort(l, mid);<br>    merge_sort(mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">//分治</span><br>    merge(l, mid, r);<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-12-05T09:12:00.000Z"><a href="/2020/12/05/个人收录颓废小游戏合集/">2020-12-05</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/05/个人收录颓废小游戏合集/">个人收录的颓废小游戏合集</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://likexia.gitee.io/game/">某小游戏合集网站</a></li>
<li><p><a target="_blank" rel="noopener" href="https://classic.minecraft.net/?join=Ej7xI-HtpR1R5-su">MC Classic网页版(你没看错,就是网页版)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.yikm.net/#www.xd0.com">小霸王游戏(网页)合集</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.yikm.net/play?id=3501&amp;n=L2Zjcm9tL2R6bXgvU3VwZXIgTWFyaW8gQnJvcy4gKFcpIFshXS5uZXM=&amp;t=%E8%B6%85%E7%BA%A7%E9%A9%AC%E9%87%8C%E5%A5%A5">超级玛丽</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://slither.io/">贪吃蛇</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.euclidea.xyz/en/game/">尺规作图</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://shindanmaker.com/162207">“我”的二次元少女形象</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://gartic.io/">你画我猜</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://krunker.io">大型像素枪战</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.xd0.com/admin/index.html?lang=cn">小黑屋</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://diep.io/">多人联机坦克大作战(diep.io)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://doblons.io/">多人联机舰船大作战(和diep.io很像)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://oj.wzms.com/HTML5dazi/">打飞字</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://slay.one/beta/">slay.one</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://namerena.github.io/">名字竞技场(很好玩!!!)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://lmoliver.github.io/mosiyuan/index.html">膜$ \textbf{S}\color{Red}iyuan$</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=TCtJMNj1wi_8miQO5peC3R__G-vYP_ab1k3EDco_on7jdwJqyxiZUBuqxJbu6grZX3x500UU3MIVIpN70uaqRa&amp;wd=&amp;eqid=8c5b8d680010b272000000035e8e7ddb">太空公司</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://pie.ai/">多人联机跳跳大作战</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://spinz.io/">贪吃陀螺</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://yorg.io/">yorg.io(塔防)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://likexia.gitee.io/cat-zh/#">猫国建设者</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://surviv.io/">吃鸡</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://img.u77.com/game/201711/LLRJU77/index.html">流浪日记(这个似乎挂了)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://file.u77.com/games/1123/clicksmith.htm">工匠</a></p>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="http://game.uixsj.cn/jfcz/">见缝插针</a></li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/颓废/">颓废</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-11-28T06:12:00.000Z"><a href="/2020/11/28/课堂笔记整合/">2020-11-28</a></time>
      
      
  
    <h1 class="title"><a href="/2020/11/28/课堂笔记整合/">课堂笔记整合</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><p><a href="https://ender-003.github.io/2020/11/28/%E6%90%9C%E7%B4%A2%E7%AC%94%E8%AE%B0/">搜索</a></p>
</li>
<li><p><a href="https://ender-003.github.io/2020/12/19/%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/">分治</a></p>
</li>
</ul>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2020-11-28T06:12:00.000Z"><a href="/2020/11/28/搜索笔记/">2020-11-28</a></time>
      
      
  
    <h1 class="title"><a href="/2020/11/28/搜索笔记/">搜索笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><blockquote>
<p>搜索，也就是对状态空间进行枚举。通过穷尽所有的可能，来找到最优解，或者统计合法解的个数。</p>
<p>搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。</p>
<p>搜索是一些高级算法的基础，在 OI 中，纯粹的搜索往往也是得到 <strong>部分分</strong> 的强有力的手段，但可以通过纯粹的搜索拿到满分的题目非常少的。</p>
</blockquote>
<hr>
<h3 id="搜索的策略：深度、广度"><a href="#搜索的策略：深度、广度" class="headerlink" title="搜索的策略：深度、广度"></a>搜索的策略：深度、广度</h3><hr>
<h3 id="重要的概念："><a href="#重要的概念：" class="headerlink" title="重要的概念："></a>重要的概念：</h3><ul>
<li>状态空间：所有合理状态的集合</li>
<li>搜索树：从初始状态出发能访问的所有状态节点及对应路径构成的一棵树</li>
<li>状态：各种属性（位置、步数、和、路径记录[有时可以用全局变量记录]）</li>
<li>初始状态：状态的各种属性为初始值</li>
<li>目标状态：一般是状态的某个属性满足一定条件下的状态，比如达到指定位置、和达到一定值</li>
<li><del>可行解：所有目标状态都是可行解</del></li>
<li>最优解：目标状态中满足最优性（某属性最小、最大）</li>
<li>解集：有时要求输出一个最优状态、有时要求输出所有的目标状态，有时要求输出任意一个目标状态</li>
</ul>
<h3 id="搜索的步骤："><a href="#搜索的步骤：" class="headerlink" title="搜索的步骤："></a>搜索的步骤：</h3><ul>
<li><p>深搜：从上往下，到底回溯，每次向下搜索都将之前一步的状态保存下来（入栈），特别地，如果用函数递归实现，除全局变量外，不需要手动去保存状态。</p>
</li>
<li><p>广搜：按层遍历，适用最优，队列中按层保存着每一层的状态。</p>
</li>
</ul>
<h3 id="搜索的优化："><a href="#搜索的优化：" class="headerlink" title="搜索的优化："></a>搜索的优化：</h3><ul>
<li>剪枝</li>
<li>回溯</li>
<li>记忆化</li>
</ul>
<h3 id="代码框架："><a href="#代码框架：" class="headerlink" title="代码框架："></a>代码框架：</h3><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">全局状态变量<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(当前状态)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(当前状态是目标状态)    <span class="hljs-comment">// 判断</span><br>        进行相应处理（计数、输出当前解、更新最优解、退出返回等）<br>     <span class="hljs-comment">// 扩展</span><br>    <span class="hljs-keyword">for</span>(所有可行的新状态)&#123;<br>        <span class="hljs-keyword">if</span>(新状态没有访问过 &amp;&amp; 需要访问)&#123; <span class="hljs-comment">// 可行性剪枝、最优性剪枝、重复性剪枝</span><br>            标记<br>            dfs(新状态)<br>            取消标记	<span class="hljs-comment">//回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>    dfs(初始状态);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">全局状态变量<br>定义状态队列<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span>&#123;<br>    初始状态入队<br>    <span class="hljs-keyword">while</span>(队列不为空)&#123;<br>        取出队首状态作为当前状态<br>        <span class="hljs-keyword">if</span>(当前状态是目标状态)<br>            进行相应处理（输出当前解、更新最优解、退出返回等）<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">for</span>(所有可行的新状态)&#123;<br>                <span class="hljs-keyword">if</span>(新状态没有访问过 &amp;&amp; 需要访问)&#123;  <span class="hljs-comment">// 可行性剪枝、最优性剪枝、重复性剪枝</span><br>                    新状态入队<br>                &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:ender-003.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2021/05/22/LaTeX,KaTeX/">LaTeX/KaTeX语法集合 --- By 离散小波变换°</a>
      </li>
    
      <li>
        <a href="/2021/05/22/最小生成树/">最小生成树</a>
      </li>
    
      <li>
        <a href="/2021/04/24/图笔记- Ⅱ/">图笔记 Ⅱ(存储&amp;便利)</a>
      </li>
    
      <li>
        <a href="/2021/04/24/图笔记-Ⅰ(性质)/">图笔记 Ⅰ(性质)</a>
      </li>
    
      <li>
        <a href="/2021/04/24/图的存储方法/"></a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Hello-World/">Hello World</a><small>1</small></li>
  
    <li><a href="/tags/OI/">OI</a><small>6</small></li>
  
    <li><a href="/tags/合集/">合集</a><small>1</small></li>
  
    <li><a href="/tags/颓废/">颓废</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Hello-World/" style="font-size: 10px;">Hello World</a> <a href="/tags/OI/" style="font-size: 20px;">OI</a> <a href="/tags/%E5%90%88%E9%9B%86/" style="font-size: 10px;">合集</a> <a href="/tags/%E9%A2%93%E5%BA%9F/" style="font-size: 15px;">颓废</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2021 Ender
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>