<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>图笔记 Ⅱ(存储&amp;便利) | Ender_&#39;s Blog</title>
  <meta name="author" content="Ender" />

  
  <meta name="description" content="存储1. 直接存边使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权）
Code:12345678910111213141516171819202122232425262728293031323334353637383940" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="图笔记 Ⅱ(存储&amp;便利)" />
  <meta property="og:site_name" content="Ender_&#39;s Blog" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="Ender_&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Ender_&#39;s Blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-04-24T09:59:59.778Z"><a href="/2021/04/24/图笔记- Ⅱ/">2021-04-24</a></time>
      
      
  
    <h1 class="title">图笔记 Ⅱ(存储&amp;便利)</h1>
  

    </header>
    <div class="entry">
      
        <h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="1-直接存边"><a href="#1-直接存边" class="headerlink" title="1. 直接存边"></a>1. 直接存边</h2><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权）</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-keyword">int</span> u, v, w;   <span class="hljs-comment">// 一条边的 起点、终点、权值</span><br>&#125;;<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-built_in">vector</span>&lt;Edge&gt; e;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; vis;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (e[i].u == u &amp;&amp; e[i].v == v) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (e[i].u == u) &#123;<br>            dfs(e[i].v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>  vis.resize(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>  e.resize(m + <span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) <span class="hljs-built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>查询是否存在某条边： $O(m)$ 。</p>
<p>遍历一个点的所有出边： $O(m)$ 。</p>
<p>遍历整张图： $O(nm)$ 。</p>
<p>空间复杂度： $O(m)$ 。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>由于直接存边的遍历效率低下，一般不用于遍历图。</p>
<p>在 $Kruskal$ 算法中，由于需要将边按边权排序，需要直接存边。</p>
<p>在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。</p>
<h2 id="2-邻接矩阵"><a href="#2-邻接矩阵" class="headerlink" title="2. 邻接矩阵"></a>2. 邻接矩阵</h2><p>使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在 u<em>u</em> 到 v<em>v</em> 的边，为 0 表示不存在。</p>
<p>如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 u<em>u</em> 到 v<em>v</em> 的边的边权，0 表示没有连接，其他值表示权重。</p>
<p>如果是无向图，则将一条无向边拆成两条方向相反的边即可。（所谓的「无向」，也就等同于「双向」）</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-keyword">bool</span> adj[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-keyword">return</span> adj[u][v]; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">return</span>;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;<br>        <span class="hljs-keyword">if</span> (adj[u][v]) &#123;<br>            dfs(v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    fill_n(vis, N, <span class="hljs-literal">false</span>);<br>    fill_n(adj, N*N, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        adj[u][v] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// u-&gt;v 有条单向边</span><br>        <span class="hljs-comment">// 如果是双向边</span><br>        <span class="hljs-comment">// adj[u][v] = adj[v][u] = true;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>查询是否存在某条边： $O(1)$ 。</p>
<p>遍历一个点的所有出边： $O(n)$ 。</p>
<p>遍历整张图： $O(n^2)$ 。</p>
<p>空间复杂度： $O(n^2)$ 。</p>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>邻接矩阵只适用于没有重边（或重边可以忽略）的情况。</p>
<p>其最显著的优点是可以 $O(1)$ 查询一条边是否存在。</p>
<p>由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会 <strong>在稠密图上使用邻接矩阵</strong>。并且，在稠密图上使用邻接矩阵的运行效率远高于邻接表，这是因为 CPU 中顺序访问的速度是远高于随机访问的（缓存命中）。</p>
<p><img src="%E5%9B%BE%E7%AC%94%E8%AE%B0.assets/%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg" alt=""></p>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">bool</span> vis[N];     <span class="hljs-comment">// 标记是否访问过</span><br><span class="hljs-keyword">bool</span> adj[N][N];  <span class="hljs-comment">// 邻接矩阵存图</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt;= n; ++v) &#123;<br>        <span class="hljs-keyword">if</span> (adj[u][v] &amp;&amp; !vis[u]) &#123;   <span class="hljs-comment">// 有边，并且没访问过，访问</span><br>            dfs(v);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br><br>    fill_n(vis, N, <span class="hljs-literal">false</span>);<br>    fill_n(adj, N*N, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u, v;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; u &gt;&gt; v;<br>        adj[u][v] = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// u-&gt;v 有条单向边</span><br>        <span class="hljs-comment">// 如果是双向边</span><br>        <span class="hljs-comment">// adj[u][v] = adj[v][u] = true;</span><br>    &#125;<br>    dfs(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">bool</span> vis[N];     <span class="hljs-comment">// 标记是否访问过</span><br><span class="hljs-keyword">bool</span> adj[N][N];  <span class="hljs-comment">// 邻接矩阵存图</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.push(s);<br>    <span class="hljs-keyword">while</span>(!q.empty()) &#123;<br>        <span class="hljs-keyword">int</span> k = q.front(); q.pop();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (adj[k][i] &amp;&amp; !vis[i])   <span class="hljs-comment">// 有边，并且没访问过，访问</span><br>            q.push(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol>
<li>时间复杂度是 $O(n^3)$ ，因此，只适用于 $n &lt; 500$ 的这种结点数不多的情况。</li>
<li>它是多源最短路的，可以求出任何两点之间的最短路。</li>
<li>支持负边权</li>
<li>能够判断图中是否存在负回路</li>
</ol>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code:"></a>Code:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dis[N][N];   <span class="hljs-comment">// dis[i][j]: i-&gt;j 最短距离 </span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">证明：定义 dis[i][j][k] 表示从 i 到 j 的可以经过 1~k 号结点的最短路径，此问题可以被分解为两个子问题</span><br><span class="hljs-comment">（1）不经过 k 号结点，即  dis[i][j][k-1]</span><br><span class="hljs-comment">（2）经过 k 号结点，即 dis[i][k][k-1]+dis[k][j][k-1];</span><br><span class="hljs-comment">因此，有：</span><br><span class="hljs-comment">dis[i][j][k] = min(dis[i][j][k-1], dis[i][k][k-1], dis[k][j][k-1]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">上式中第三维 k 可以省略，则有： </span><br><span class="hljs-comment">dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">虽然 i,j,k 的顺序不保证，导致上式中 dis[i][k] 和 dis[k][j] 可能是已经被更新过的 dis[i][k][k] 和 dis[k][j][k] 了，</span><br><span class="hljs-comment">但是这并不影响其正确性。因为更新后的值一定会变得更小，不会影响最终结果。 </span><br><span class="hljs-comment">*/</span> <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; g[i][j];<br>            dis[i][j] = g[i][j];<br>        &#125;<br>    <span class="hljs-comment">// floyd 求任意两点间的最短路径 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)   <span class="hljs-comment">// 枚举中间点 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n;j++)<br>                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);<br>                <br>    <span class="hljs-comment">// 判断负环 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[i][i] &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;存在负环&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;       <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><p>只适用于正权边</p>
<p>思想是贪心的思想</p>
<p>朴素版 $Dijkstra$ 适合稠密图</p>
<h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>集合S为已经确定最短路径的点集。</p>
<ol>
<li>初始化距离： $1$ 号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。</li>
<li>循环 $n$ 次，每一次将集合 $S$ 之外距离最短 $X$ 的点加入到 $S$ 中去（这里的距离最短指的是距离 $1$ 号点最近。点 $X$ 的路径一定最短，基于贪心，严格证明待看）。然后用点 $X$ 更新 $X$ 邻接点的距离。</li>
</ol>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>寻找路径最短的点：$O(n^2)$</p>
<p>加入集合 $S$：$O(n)$</p>
<p>更新距离：$O(m)$</p>
<p>所以总的时间复杂度为 $O(n^2)$</p>
<h4 id="Code-3"><a href="#Code-3" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-comment">//邻接矩阵</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct node&#123;</span><br><span class="hljs-comment">	int id, w;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">vector&lt;node&gt; g[N];</span><br><span class="hljs-comment">//邻接表</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> visited[N];   <span class="hljs-comment">// 依据访问过与否将所有节点分成两个部分(集合)</span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-comment">// 确定集合中距离初始节点最近的点 t</span><br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))<br>                t = j;<br>        &#125;<br>        visited[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 加入 S 集合</span><br>        <span class="hljs-comment">// 从 t 出发，更新相邻点的 dist</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            dist[j] = min(dist[j], dist[t] + g[t][j]);<br>        	<span class="hljs-comment">//dist[j] = min(dist[j], dist[t] + g[t][j].w);</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(g));<br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        g[x][y] = min(g[x][y], c);   <span class="hljs-comment">// 因为有重边，所以只保留最短边</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆优化-Dijkstra"><a href="#堆优化-Dijkstra" class="headerlink" title="堆优化 Dijkstra"></a>堆优化 Dijkstra</h3><blockquote>
<p>任何场景均适合</p>
</blockquote>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>堆优化版的 $Dijkstra$ 是对朴素版 $Dijkstra$ 进行了优化，在朴素版 $Dijkstra$ 中时间复杂度最高的寻找距离最短的点 $O(n^2)$ 可以使用最小堆优化。</p>
<ol>
<li>1 号点的距离初始化为零，其他点初始化成无穷大。</li>
<li>将一号点放入堆中。</li>
<li>不断循环，直到堆空。每一次循环中执行的操作为： 弹出堆顶（与朴素版 $dijkstra$ 找到 $S$ 外距离最短的点相同，并标记该点的最短路径已经确定）。 用该点更新临界点的距离，若更新成功就加入到堆中。</li>
</ol>
<h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>寻找路径最短的点：$O(n)$</p>
<p>加入集合S：$O(n)$</p>
<p>更新距离：$O(mlog_n)$</p>
<p>所以总的时间复杂度为 $O(m{log}_n)$</p>
<h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">150010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> y, w;<br>&#125;;<br><br><span class="hljs-built_in">vector</span>&lt;node&gt; g[N];<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">// 如果为true说明这个点的最短路径已经确定</span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    g[x].push_back((node)&#123;y, c&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt; &gt; q; <span class="hljs-comment">// 定义一个小根堆</span><br>    <span class="hljs-comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    </span><br>    <span class="hljs-comment">// 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span><br>    q.push(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span><br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        PII tmp = q.top(); <span class="hljs-comment">// 取不在集合S中距离最短的点</span><br>        q.pop();<br>        <span class="hljs-keyword">int</span> cur = tmp.second, d = tmp.first;<br><br>        <span class="hljs-keyword">if</span>(st[cur]) <span class="hljs-keyword">continue</span>;<br>        st[cur] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加入集合 S 中</span><br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g[cur].size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> id = g[cur][i].y, w = g[cur][i].w;<br>            <span class="hljs-keyword">if</span>(dist[id] &gt; d + w)<br>            &#123;<br>                dist[id] = d + w;<br>                q.push(&#123; dist[id], id &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        add(x, y, c);<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="链式前向星写法"><a href="#链式前向星写法" class="headerlink" title="链式前向星写法"></a>链式前向星写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">150010</span>;<br><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-keyword">int</span> w[N]; <span class="hljs-comment">// 用来存权重</span><br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N]; <span class="hljs-comment">// 如果为true说明这个点的最短路径已经确定</span><br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-comment">// 稀疏图用链式前向星来存</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    w[idx] = c; <span class="hljs-comment">// 有重边也不要紧，假设1-&gt;2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中</span><br>    e[idx] = y; <span class="hljs-comment">// 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），并</span><br>    ne[idx] = h[x]; <span class="hljs-comment">// 标记st为true，所以下一次弹出3+x会continue不会向下执行。</span><br>    h[x] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span>(dist));<br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">priority_queue</span>&lt;PII, <span class="hljs-built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; q; <span class="hljs-comment">// 定义一个小根堆</span><br>    <span class="hljs-comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    </span><br>    <span class="hljs-comment">// 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span><br>    q.push(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span><br>    <span class="hljs-keyword">while</span>(!q.empty())<br>    &#123;<br>        PII k = q.top(); <span class="hljs-comment">// 取不在集合S中距离最短的点</span><br>        q.pop();<br>        <span class="hljs-keyword">int</span> ver = k.second, distance = k.first;<br><br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 加入集合 S 中</span><br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = e[i]; <span class="hljs-comment">// i只是个下标，e中在存的是i这个下标对应的点。</span><br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                q.push(&#123; dist[j], j &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(h));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> x, y, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);<br>        add(x, y, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">cout</span> &lt;&lt; dijkstra() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/OI/">OI</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:ender-003.github.io">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2021/05/22/LaTeX,KaTeX/">LaTeX/KaTeX语法集合 --- By 离散小波变换°</a>
      </li>
    
      <li>
        <a href="/2021/05/22/最小生成树/">最小生成树</a>
      </li>
    
      <li>
        <a href="/2021/04/24/图笔记- Ⅱ/">图笔记 Ⅱ(存储&amp;便利)</a>
      </li>
    
      <li>
        <a href="/2021/04/24/图笔记-Ⅰ(性质)/">图笔记 Ⅰ(性质)</a>
      </li>
    
      <li>
        <a href="/2021/04/24/图的存储方法/"></a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Hello-World/">Hello World</a><small>1</small></li>
  
    <li><a href="/tags/OI/">OI</a><small>6</small></li>
  
    <li><a href="/tags/合集/">合集</a><small>1</small></li>
  
    <li><a href="/tags/颓废/">颓废</a><small>2</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Hello-World/" style="font-size: 10px;">Hello World</a> <a href="/tags/OI/" style="font-size: 20px;">OI</a> <a href="/tags/%E5%90%88%E9%9B%86/" style="font-size: 10px;">合集</a> <a href="/tags/%E9%A2%93%E5%BA%9F/" style="font-size: 15px;">颓废</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2021 Ender
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>